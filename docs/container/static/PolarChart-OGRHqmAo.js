import {
  bM as jt,
  r as Rt,
  j as yt,
  b6 as Lt,
  t as At,
  cx as Nt,
  u as kt,
  a as It,
  Y as Et,
  a1 as Dt
} from "./index-3WWdADc-.js";
import {
  L as Bt
} from "./Chart-Unl7pYTV.js";
import {
  H as zt
} from "./highcharts-3nykS9Sh.js";
import {
  r as Ct
} from "./server.browser-XcXyx2ie.js";
import {
  u as Ot
} from "./index-RORsozqH.js";
import {
  b as Wt
} from "./EditProductIdeaName-gWrXHheR.js";
import {
  a as Gt
} from "./AddToMyListDropdown-j1WBFoh0.js";
import "./highcharts-react.min-km6L4za6.js";
import "./mergeRefs-97mQYrgp.js";
import "./merge-q4iB0WCC.js";
import "./Learn-iEpSD2rS.js";
import "./useAutoPlay-ceAGW3YF.js";
import "./_initCloneObject-fWvGzI93.js";
import "./isPlainObject-fpFAdWHq.js";
import "./main-DKZdTZ3T.js";
import "./index-7v7JHEmS.js";
import "./index-JL-77yQX.js";
import "./useCommonProductsStore-vDkIGl3q.js";
import "./TagsMultiSelect-PKy7h-4F.js";
import "./middleware-lPGLX8nq.js";
import "./use-latest.esm-1HraH-At.js";
import "./TitleWithTooltip-5sfAnl-u.js";
import "./StatusChip-FrPKlZU9.js";
import "./iterators-xaJT6-Vu.js";
import "./ShowMore-3rW6__yJ.js";
import "./ActionTitle-MUSq5Ytj.js";
import "./getMarketplaceLinkForProduct-A-zEKrnh.js";
import "./NewRadio-r0LBmnQI.js";
import "./AboveTable-inLMfERi.js";
import "./CustomerEventsComponent-YmM_p4Tw.js";
import "./CategoricalChip-4k4IDblM.js";
import "./Collapse-tP42S7bB.js";
import "./ProductChip-uftlxV5Z.js";
import "./configuration-HeGlZf9h.js";
import "./leitenList-ZXI2GTpH.js";
import "./ProductMultiSelect-F_pvYcVx.js";
import "./NewSimpleTable-66rkfBtT.js";
import "./index-yZJ9ROn4.js";
import "./zustandGroupSlice-_dr0CS-x.js";
import "./ChartExport-xG8FR1Rx.js";
import "./LineGraphSkeleton-eFZ_jC28.js";
import "./withCustomerEvents-3bS6SySO.js";
import "./orderBy-FznrKSHo.js";
import "./_baseMap-5lV6NFoL.js";
import "./ExtendedProductSummary-BHNYmxm-.js";
import "./index-dYT0PsCY.js";
import "./index-IyiqQa2_.js";
import "./Minmax-CRxFfvVO.js";
import "./lodash-EELJ18yH.js";
import "./ProfitsProductSelect-F627cyUH.js";
import "./index-9zDi9ihJ.js";
import "./index-ePDqUNZh.js";
import "./zustandPrimitive-JpIny_aS.js";
import "./SearchGraphModal-Qx3Zfqc8.js";
import "./redirectToSubscribe-18BB2MSS.js";
import "./OptimalData-it69sBiU.js";
import "./use-onclickoutside.browser.esm-FI41Hp9Z.js";
import "./ChoiceBadge-RypXZaAe.js";
import "./LockedTitle-qegsyrMP.js";
import "./StorageFeeCell-_Xhz7YT0.js";
import "./groupBy-U0u9Occh.js";
import "./dateRanges-u9-eXTpH.js";
import "./react-alice-carousel-NHcyKvdv.js";
import "./hooks-pZqYqtY6.js";
import "./getListingAnalyzerKeywordsSection-jqe5lzYl.js";
import "./TrafficAndConversion-6jLZMhF2.js";
import "./index-4X1FVNh6.js";
import "./AirTable-8H-5frrn.js";
import "./xor-VMbe2DzQ.js";
import "./HistoryButton-38bzMA4-.js";
import "./useChartLegend-vX-4JLXm.js";
import "./GraphTooltip--eldlCAK.js";
import "./pick-9wP-R-Np.js";
import "./_basePickBy-TRWQGAlr.js";
import "./MwsTokenSelector-fbhfIU4N.js";
import "./omit-qko51Z9O.js";
import "./_baseSlice-dEb6GWcI.js";
import "./NewMenu-3awjWawA.js";
import "./index.browser-zSPcFHrV.js";
import "./FloatingModal-e3XDdj19.js";
import "./cjs-AlizaDQK.js";
import "./useWindowSize-v2uNOjYr.js";
import "./leitenGridLayout-3xa3XTWr.js";
import "./InputChip-MgUFoGrT.js";
import "./getCountryName-Z07pMYy4.js";
import "./getCurrencySymbol-f-JVoba0.js";
import "./WidthAndHeightLimitedItems-A7in_yrZ.js";
import "./Competitors-H9fPwkOM.js";
import "./useUSelectAutocomplete-qWwjhQCG.js";
import "./FilterButton-tb4Aaz_e.js";
import "./WistiaVideo-x0Y3z35k.js";
import "./NewRecommendedToken-KFmJ8xQW.js";
import "./NumberIndicator-vcbzcNgG.js";
import "./MarketplaceSingleSelect-pf9DJN8d.js";
import "./ACoSCell-ybGdKbwd.js";
import "./isString-h0T1fcsV.js";
import "./GoogleAdsLogo-aN0nJl0u.js";
import "./productIdeaScorecard-_ReoIqql.js";
import "./ProductCard-zUkYqdRP.js";
import "./useTableComponents-G0in92JQ.js";
import "./RangeInput-92zISmxH.js";
import "./Stepper-rotTaXUX.js";
import "./ToastContainer-r564VdJO.js";
var Tt = {
  exports: {}
};
(function(pt) {
  (function(gt) {
    pt.exports ? (gt.default = gt, pt.exports = gt) : gt(typeof Highcharts < "u" ? Highcharts : void 0)
  })(function(gt) {
    var d = gt ? gt._modules : {};

    function ot(h, u, x, g) {
      h.hasOwnProperty(u) || (h[u] = g.apply(null, x), typeof CustomEvent == "function" && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
        detail: {
          path: u,
          module: h[u]
        }
      })))
    }
    ot(d, "Extensions/Pane/PaneComposition.js", [d["Core/Utilities.js"]], function(h) {
      let {
        addEvent: u,
        correctFloat: x,
        defined: g,
        pick: j
      } = h;

      function T(M) {
        let y, n = this;
        return M && n.pane.forEach(b => {
          k(M.chartX - n.plotLeft, M.chartY - n.plotTop, b.center) && (y = b)
        }), y
      }

      function k(M, y, n, b, e) {
        let p = !0,
            a = n[0],
            s = n[1];
        if (g(b) && g(e)) {
          let t = Math.atan2(x(y - s, 8), x(M - a, 8));
          e !== b && (p = b > e ? t >= b && t <= Math.PI || t <= e && t >= -Math.PI : t >= b && t <= x(e, 8))
        }
        return Math.sqrt(Math.pow(M - a, 2) + Math.pow(y - s, 2)) <= Math.ceil(n[2] / 2) && p
      }

      function R(M) {
        this.polar && (M.options.inverted && ([M.x, M.y] = [M.y, M.x]), M.isInsidePlot = this.pane.some(y => k(M.x, M.y, y.center, y.axis && y.axis.normalizedStartAngleRad, y.axis && y.axis.normalizedEndAngleRad)))
      }

      function H(M) {
        let y = this.chart;
        M.hoverPoint && M.hoverPoint.plotX && M.hoverPoint.plotY && y.hoverPane && !k(M.hoverPoint.plotX, M.hoverPoint.plotY, y.hoverPane.center) && (M.hoverPoint = void 0)
      }

      function I(M) {
        let y = this.chart;
        y.polar ? (y.hoverPane = y.getHoverPane(M), M.filter = function(n) {
          return n.visible && !(!M.shared && n.directTouch) && j(n.options.enableMouseTracking, !0) && (!y.hoverPane || n.xAxis.pane === y.hoverPane)
        }) : y.hoverPane = void 0
      }
      return {
        compose: function(M, y) {
          let n = M.prototype;
          n.getHoverPane || (n.collectionsWithUpdate.push("pane"), n.getHoverPane = T, u(M, "afterIsInsidePlot", R), u(y, "afterGetHoverData", H), u(y, "beforeGetHoverData", I))
        }
      }
    }), ot(d, "Extensions/Pane/PaneDefaults.js", [], function() {
      return {
        pane: {
          center: ["50%", "50%"],
          size: "85%",
          innerSize: "0%",
          startAngle: 0
        },
        background: {
          shape: "circle",
          borderWidth: 1,
          borderColor: "#cccccc",
          backgroundColor: {
            linearGradient: {
              x1: 0,
              y1: 0,
              x2: 0,
              y2: 1
            },
            stops: [
              [0, "#ffffff"],
              [1, "#e6e6e6"]
            ]
          },
          from: -Number.MAX_VALUE,
          innerRadius: 0,
          to: Number.MAX_VALUE,
          outerRadius: "105%"
        }
      }
    }), ot(d, "Extensions/Pane/Pane.js", [d["Series/CenteredUtilities.js"], d["Extensions/Pane/PaneComposition.js"], d["Extensions/Pane/PaneDefaults.js"], d["Core/Utilities.js"]], function(h, u, x, g) {
      let {
        extend: j,
        merge: T,
        splat: k
      } = g;
      class R {
        constructor(I, M) {
          this.coll = "pane", this.init(I, M)
        }
        init(I, M) {
          this.chart = M, this.background = [], M.pane.push(this), this.setOptions(I)
        }
        setOptions(I) {
          this.options = I = T(x.pane, this.chart.angular ? {
            background: {}
          } : void 0, I)
        }
        render() {
          let I = this.options,
              M = this.chart.renderer;
          this.group || (this.group = M.g("pane-group").attr({
            zIndex: I.zIndex || 0
          }).add()), this.updateCenter();
          let y = this.options.background;
          if (y) {
            let n = Math.max((y = k(y)).length, this.background.length || 0);
            for (let b = 0; b < n; b++) y[b] && this.axis ? this.renderBackground(T(x.background, y[b]), b) : this.background[b] && (this.background[b] = this.background[b].destroy(), this.background.splice(b, 1))
          }
        }
        renderBackground(I, M) {
          let y = {
                class: "highcharts-pane " + (I.className || "")
              },
              n = "animate";
          this.chart.styledMode || j(y, {
            fill: I.backgroundColor,
            stroke: I.borderColor,
            "stroke-width": I.borderWidth
          }), this.background[M] || (this.background[M] = this.chart.renderer.path().add(this.group), n = "attr"), this.background[M][n]({
            d: this.axis.getPlotBandPath(I.from, I.to, I)
          }).attr(y)
        }
        updateCenter(I) {
          this.center = (I || this.axis || {}).center = h.getCenter.call(this)
        }
        update(I, M) {
          T(!0, this.options, I), this.setOptions(this.options), this.render(), this.chart.axes.forEach(function(y) {
            y.pane === this && (y.pane = null, y.update({}, M))
          }, this)
        }
      }
      return R.compose = u.compose, R
    }), ot(d, "Series/AreaRange/AreaRangePoint.js", [d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u) {
      let {
        area: {
          prototype: {
            pointClass: x,
            pointClass: {
              prototype: g
            }
          }
        }
      } = h.seriesTypes, {
        defined: j,
        isNumber: T
      } = u;
      return class extends x {
        setState() {
          let k = this.state,
              R = this.series,
              H = R.chart.polar;
          j(this.plotHigh) || (this.plotHigh = R.yAxis.toPixels(this.high, !0)), j(this.plotLow) || (this.plotLow = this.plotY = R.yAxis.toPixels(this.low, !0)), R.lowerStateMarkerGraphic = R.stateMarkerGraphic, R.stateMarkerGraphic = R.upperStateMarkerGraphic, this.graphic = this.graphics && this.graphics[1], this.plotY = this.plotHigh, H && T(this.plotHighX) && (this.plotX = this.plotHighX), g.setState.apply(this, arguments), this.state = k, this.plotY = this.plotLow, this.graphic = this.graphics && this.graphics[0], H && T(this.plotLowX) && (this.plotX = this.plotLowX), R.upperStateMarkerGraphic = R.stateMarkerGraphic, R.stateMarkerGraphic = R.lowerStateMarkerGraphic, R.lowerStateMarkerGraphic = void 0;
          let I = R.modifyMarkerSettings();
          g.setState.apply(this, arguments), R.restoreMarkerSettings(I)
        }
        haloPath() {
          let k = this.series.chart.polar,
              R = [];
          return this.plotY = this.plotLow, k && T(this.plotLowX) && (this.plotX = this.plotLowX), this.isInside && (R = g.haloPath.apply(this, arguments)), this.plotY = this.plotHigh, k && T(this.plotHighX) && (this.plotX = this.plotHighX), this.isTopInside && (R = R.concat(g.haloPath.apply(this, arguments))), R
        }
        isValid() {
          return T(this.low) && T(this.high)
        }
      }
    }), ot(d, "Series/AreaRange/AreaRangeSeries.js", [d["Series/AreaRange/AreaRangePoint.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x, g) {
      let {
        noop: j
      } = u, {
        area: T,
        area: {
          prototype: k
        },
        column: {
          prototype: R
        }
      } = x.seriesTypes, {
        addEvent: H,
        defined: I,
        extend: M,
        isArray: y,
        isNumber: n,
        pick: b,
        merge: e
      } = g;
      class p extends T {
        toYData(s) {
          return [s.low, s.high]
        }
        highToXY(s) {
          let t = this.chart,
              r = this.xAxis.postTranslate(s.rectPlotX || 0, this.yAxis.len - (s.plotHigh || 0));
          s.plotHighX = r.x - t.plotLeft, s.plotHigh = r.y - t.plotTop, s.plotLowX = s.plotX
        }
        getGraphPath(s) {
          let t = [],
              r = [],
              P = k.getGraphPath,
              L = this.options,
              B = this.chart.polar,
              S = B && L.connectEnds !== !1,
              Y = L.connectNulls,
              X, C, i, o = L.step;
          for (X = (s = s || this.points).length; X--;) {
            C = s[X];
            let A = B ? {
              plotX: C.rectPlotX,
              plotY: C.yBottom,
              doCurve: !1
            } : {
              plotX: C.plotX,
              plotY: C.plotY,
              doCurve: !1
            };
            C.isNull || S || Y || s[X + 1] && !s[X + 1].isNull || r.push(A), i = {
              polarPlotY: C.polarPlotY,
              rectPlotX: C.rectPlotX,
              yBottom: C.yBottom,
              plotX: b(C.plotHighX, C.plotX),
              plotY: C.plotHigh,
              isNull: C.isNull
            }, r.push(i), t.push(i), C.isNull || S || Y || s[X - 1] && !s[X - 1].isNull || r.push(A)
          }
          let f = P.call(this, s);
          o && (o === !0 && (o = "left"), L.step = {
            left: "right",
            center: "center",
            right: "left"
          } [o]);
          let m = P.call(this, t),
              w = P.call(this, r);
          L.step = o;
          let c = [].concat(f, m);
          return !this.chart.polar && w[0] && w[0][0] === "M" && (w[0] = ["L", w[0][1], w[0][2]]), this.graphPath = c, this.areaPath = f.concat(w), c.isArea = !0, c.xMap = f.xMap, this.areaPath.xMap = f.xMap, c
        }
        drawDataLabels() {
          var i, o;
          let s, t, r, P, L, B = this.points,
              S = B.length,
              Y = [],
              X = this.options.dataLabels,
              C = this.chart.inverted;
          if (X) {
            if (y(X) ? (P = X[0] || {
              enabled: !1
            }, L = X[1] || {
              enabled: !1
            }) : ((P = M({}, X)).x = X.xHigh, P.y = X.yHigh, (L = M({}, X)).x = X.xLow, L.y = X.yLow), P.enabled || ((i = this.hasDataLabels) == null ? void 0 : i.call(this))) {
              for (s = S; s--;)
                if (t = B[s]) {
                  let {
                    plotHigh: f = 0,
                    plotLow: m = 0
                  } = t;
                  r = P.inside ? f < m : f > m, t.y = t.high, t._plotY = t.plotY, t.plotY = f, Y[s] = t.dataLabel, t.dataLabel = t.dataLabelUpper, t.below = r, C ? P.align || (P.align = r ? "right" : "left") : P.verticalAlign || (P.verticalAlign = r ? "top" : "bottom")
                } for (this.options.dataLabels = P, k.drawDataLabels && k.drawDataLabels.apply(this, arguments), s = S; s--;)(t = B[s]) && (t.dataLabelUpper = t.dataLabel, t.dataLabel = Y[s], delete t.dataLabels, t.y = t.low, t.plotY = t._plotY)
            }
            if (L.enabled || (o = this.hasDataLabels) != null && o.call(this)) {
              for (s = S; s--;)
                if (t = B[s]) {
                  let {
                    plotHigh: f = 0,
                    plotLow: m = 0
                  } = t;
                  r = L.inside ? f < m : f > m, t.below = !r, C ? L.align || (L.align = r ? "left" : "right") : L.verticalAlign || (L.verticalAlign = r ? "bottom" : "top")
                } this.options.dataLabels = L, k.drawDataLabels && k.drawDataLabels.apply(this, arguments)
            }
            if (P.enabled)
              for (s = S; s--;)(t = B[s]) && (t.dataLabels = [t.dataLabelUpper, t.dataLabel].filter(function(f) {
                return !!f
              }));
            this.options.dataLabels = X
          }
        }
        alignDataLabel() {
          R.alignDataLabel.apply(this, arguments)
        }
        modifyMarkerSettings() {
          let s = {
            marker: this.options.marker,
            symbol: this.symbol
          };
          if (this.options.lowMarker) {
            let {
              options: {
                marker: t,
                lowMarker: r
              }
            } = this;
            this.options.marker = e(t, r), r.symbol && (this.symbol = r.symbol)
          }
          return s
        }
        restoreMarkerSettings(s) {
          this.options.marker = s.marker, this.symbol = s.symbol
        }
        drawPoints() {
          let s, t, r = this.points.length,
              P = this.modifyMarkerSettings();
          for (k.drawPoints.apply(this, arguments), this.restoreMarkerSettings(P), s = 0; s < r;)(t = this.points[s]).graphics = t.graphics || [], t.origProps = {
            plotY: t.plotY,
            plotX: t.plotX,
            isInside: t.isInside,
            negative: t.negative,
            zone: t.zone,
            y: t.y
          }, (t.graphic || t.graphics[0]) && (t.graphics[0] = t.graphic), t.graphic = t.graphics[1], t.plotY = t.plotHigh, I(t.plotHighX) && (t.plotX = t.plotHighX), t.y = b(t.high, t.origProps.y), t.negative = t.y < (this.options.threshold || 0), this.zones.length && (t.zone = t.getZone()), this.chart.polar || (t.isInside = t.isTopInside = t.plotY !== void 0 && t.plotY >= 0 && t.plotY <= this.yAxis.len && t.plotX >= 0 && t.plotX <= this.xAxis.len), s++;
          for (k.drawPoints.apply(this, arguments), s = 0; s < r;)(t = this.points[s]).graphics = t.graphics || [], (t.graphic || t.graphics[1]) && (t.graphics[1] = t.graphic), t.graphic = t.graphics[0], t.origProps && (M(t, t.origProps), delete t.origProps), s++
        }
        hasMarkerChanged(s, t) {
          let r = s.lowMarker,
              P = t.lowMarker || {};
          return r && (r.enabled === !1 || P.symbol !== r.symbol || P.height !== r.height || P.width !== r.width) || super.hasMarkerChanged(s, t)
        }
      }
      return p.defaultOptions = e(T.defaultOptions, {
        lineWidth: 1,
        threshold: null,
        tooltip: {
          pointFormat: '<span style="color:{series.color}">鈼�</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
        },
        trackByArea: !0,
        dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          xLow: 0,
          xHigh: 0,
          yLow: 0,
          yHigh: 0
        }
      }), H(p, "afterTranslate", function() {
        this.pointArrayMap.join(",") === "low,high" && this.points.forEach(a => {
          let s = a.high,
              t = a.plotY;
          a.isNull ? a.plotY = void 0 : (a.plotLow = t, a.plotHigh = n(s) ? this.yAxis.translate(this.dataModify ? this.dataModify.modifyValue(s) : s, !1, !0, void 0, !0) : void 0, this.dataModify && (a.yBottom = a.plotHigh))
        })
      }, {
        order: 0
      }), H(p, "afterTranslate", function() {
        this.points.forEach(a => {
          if (this.chart.polar) this.highToXY(a), a.plotLow = a.plotY, a.tooltipPos = [((a.plotHighX || 0) + (a.plotLowX || 0)) / 2, ((a.plotHigh || 0) + (a.plotLow || 0)) / 2];
          else {
            let s = a.pos(!1, a.plotLow),
                t = a.pos(!1, a.plotHigh);
            s && t && (s[0] = (s[0] + t[0]) / 2, s[1] = (s[1] + t[1]) / 2), a.tooltipPos = s
          }
        })
      }, {
        order: 3
      }), M(p.prototype, {
        deferTranslatePolar: !0,
        pointArrayMap: ["low", "high"],
        pointClass: h,
        pointValKey: "low",
        setStackedPoints: j
      }), x.registerSeriesType("arearange", p), p
    }), ot(d, "Series/AreaSplineRange/AreaSplineRangeSeries.js", [d["Series/AreaRange/AreaRangeSeries.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x) {
      let {
        spline: {
          prototype: g
        }
      } = u.seriesTypes, {
        merge: j,
        extend: T
      } = x;
      class k extends h {}
      return k.defaultOptions = j(h.defaultOptions), T(k.prototype, {
        getPointSpline: g.getPointSpline
      }), u.registerSeriesType("areasplinerange", k), k
    }), ot(d, "Series/BoxPlot/BoxPlotSeriesDefaults.js", [], function() {
      return {
        threshold: null,
        tooltip: {
          pointFormat: '<span style="color:{point.color}">鈼�</span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'
        },
        whiskerLength: "50%",
        fillColor: "#ffffff",
        lineWidth: 1,
        medianWidth: 2,
        whiskerWidth: 2
      }
    }), ot(d, "Series/BoxPlot/BoxPlotSeries.js", [d["Series/BoxPlot/BoxPlotSeriesDefaults.js"], d["Series/Column/ColumnSeries.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x, g, j) {
      let {
        noop: T
      } = x, {
        extend: k,
        merge: R,
        pick: H
      } = j;
      class I extends u {
        pointAttribs() {
          return {}
        }
        translate() {
          let y = this.yAxis,
              n = this.pointArrayMap;
          super.translate.apply(this), this.points.forEach(function(b) {
            n.forEach(function(e) {
              b[e] !== null && (b[e + "Plot"] = y.translate(b[e], 0, 1, 0, 1))
            }), b.plotHigh = b.highPlot
          })
        }
        drawPoints() {
          let y = this.points,
              n = this.options,
              b = this.chart,
              e = b.renderer,
              p = this.doQuartiles !== !1,
              a = this.options.whiskerLength,
              s, t, r, P, L, B, S, Y = 0,
              X, C, i, o, f, m, w;
          for (let c of y) {
            let A = (C = c.graphic) ? "animate" : "attr",
                _ = c.shapeArgs,
                F = {},
                tt = {},
                J = {},
                U = {},
                l = c.color || this.color;
            if (c.plotY !== void 0) {
              let N;
              i = Math.round(_.width), f = (o = Math.floor(_.x)) + i, m = Math.round(i / 2), s = Math.floor(p ? c.q1Plot : c.lowPlot), t = Math.floor(p ? c.q3Plot : c.lowPlot), r = Math.floor(c.highPlot), P = Math.floor(c.lowPlot), C || (c.graphic = C = e.g("point").add(this.group), c.stem = e.path().addClass("highcharts-boxplot-stem").add(C), a && (c.whiskers = e.path().addClass("highcharts-boxplot-whisker").add(C)), p && (c.box = e.path(X).addClass("highcharts-boxplot-box").add(C)), c.medianShape = e.path(B).addClass("highcharts-boxplot-median").add(C)), b.styledMode || (tt.stroke = c.stemColor || n.stemColor || l, tt["stroke-width"] = H(c.stemWidth, n.stemWidth, n.lineWidth), tt.dashstyle = c.stemDashStyle || n.stemDashStyle || n.dashStyle, c.stem.attr(tt), a && (J.stroke = c.whiskerColor || n.whiskerColor || l, J["stroke-width"] = H(c.whiskerWidth, n.whiskerWidth, n.lineWidth), J.dashstyle = c.whiskerDashStyle || n.whiskerDashStyle || n.dashStyle, c.whiskers.attr(J)), p && (F.fill = c.fillColor || n.fillColor || l, F.stroke = n.lineColor || l, F["stroke-width"] = n.lineWidth || 0, F.dashstyle = c.boxDashStyle || n.boxDashStyle || n.dashStyle, c.box.attr(F)), U.stroke = c.medianColor || n.medianColor || l, U["stroke-width"] = H(c.medianWidth, n.medianWidth, n.lineWidth), U.dashstyle = c.medianDashStyle || n.medianDashStyle || n.dashStyle, c.medianShape.attr(U)), N = [
                ["M", Y = o + m + (S = c.stem.strokeWidth() % 2 / 2), t],
                ["L", Y, r],
                ["M", Y, s],
                ["L", Y, P]
              ], c.stem[A]({
                d: N
              }), p && (s = Math.floor(s) + (S = c.box.strokeWidth() % 2 / 2), t = Math.floor(t) + S, o += S, f += S, N = [
                ["M", o, t],
                ["L", o, s],
                ["L", f, s],
                ["L", f, t],
                ["L", o, t],
                ["Z"]
              ], c.box[A]({
                d: N
              })), a && (r += S = c.whiskers.strokeWidth() % 2 / 2, P += S, N = [
                ["M", Y - (w = /%$/.test(a) ? m * parseFloat(a) / 100 : a / 2), r],
                ["L", Y + w, r],
                ["M", Y - w, P],
                ["L", Y + w, P]
              ], c.whiskers[A]({
                d: N
              })), N = [
                ["M", o, L = Math.round(c.medianPlot) + (S = c.medianShape.strokeWidth() % 2 / 2)],
                ["L", f, L]
              ], c.medianShape[A]({
                d: N
              })
            }
          }
        }
        toYData(y) {
          return [y.low, y.q1, y.median, y.q3, y.high]
        }
      }
      return I.defaultOptions = R(u.defaultOptions, h), k(I.prototype, {
        pointArrayMap: ["low", "q1", "median", "q3", "high"],
        pointValKey: "high",
        drawDataLabels: T,
        setStackedPoints: T
      }), g.registerSeriesType("boxplot", I), I
    }), ot(d, "Series/Bubble/BubbleLegendDefaults.js", [], function() {
      return {
        borderColor: void 0,
        borderWidth: 2,
        className: void 0,
        color: void 0,
        connectorClassName: void 0,
        connectorColor: void 0,
        connectorDistance: 60,
        connectorWidth: 1,
        enabled: !1,
        labels: {
          className: void 0,
          allowOverlap: !1,
          format: "",
          formatter: void 0,
          align: "right",
          style: {
            fontSize: "0.9em",
            color: "#000000"
          },
          x: 0,
          y: 0
        },
        maxSize: 60,
        minSize: 10,
        legendIndex: 0,
        ranges: {
          value: void 0,
          borderColor: void 0,
          color: void 0,
          connectorColor: void 0
        },
        sizeBy: "area",
        sizeByAbsoluteValue: !1,
        zIndex: 1,
        zThreshold: 0
      }
    }), ot(d, "Series/Bubble/BubbleLegendItem.js", [d["Core/Color/Color.js"], d["Core/Templating.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function(h, u, x, g) {
      let {
        parse: j
      } = h, {
        noop: T
      } = x, {
        arrayMax: k,
        arrayMin: R,
        isNumber: H,
        merge: I,
        pick: M,
        stableSort: y
      } = g;
      return class {
        constructor(n, b) {
          this.setState = T, this.init(n, b)
        }
        init(n, b) {
          this.options = n, this.visible = !0, this.chart = b.chart, this.legend = b
        }
        addToLegend(n) {
          n.splice(this.options.legendIndex, 0, this)
        }
        drawLegendSymbol(n) {
          let b, e = M(n.options.itemDistance, 20),
              p = this.legendItem || {},
              a = this.options,
              s = a.ranges,
              t = a.connectorDistance;
          if (!s || !s.length || !H(s[0].value)) {
            n.options.bubbleLegend.autoRanges = !0;
            return
          }
          y(s, function(B, S) {
            return S.value - B.value
          }), this.ranges = s, this.setOptions(), this.render();
          let r = this.getMaxLabelSize(),
              P = this.ranges[0].radius,
              L = 2 * P;
          b = (b = t - P + r.width) > 0 ? b : 0, this.maxLabel = r, this.movementX = a.labels.align === "left" ? b : 0, p.labelWidth = L + b + e, p.labelHeight = L + r.height / 2
        }
        setOptions() {
          let n = this.ranges,
              b = this.options,
              e = this.chart.series[b.seriesIndex],
              p = this.legend.baseline,
              a = {
                zIndex: b.zIndex,
                "stroke-width": b.borderWidth
              },
              s = {
                zIndex: b.zIndex,
                "stroke-width": b.connectorWidth
              },
              t = {
                align: this.legend.options.rtl || b.labels.align === "left" ? "right" : "left",
                zIndex: b.zIndex
              },
              r = e.options.marker.fillOpacity,
              P = this.chart.styledMode;
          n.forEach(function(L, B) {
            P || (a.stroke = M(L.borderColor, b.borderColor, e.color), a.fill = M(L.color, b.color, r !== 1 ? j(e.color).setOpacity(r).get("rgba") : e.color), s.stroke = M(L.connectorColor, b.connectorColor, e.color)), n[B].radius = this.getRangeRadius(L.value), n[B] = I(n[B], {
              center: n[0].radius - n[B].radius + p
            }), P || I(!0, n[B], {
              bubbleAttribs: I(a),
              connectorAttribs: I(s),
              labelAttribs: t
            })
          }, this)
        }
        getRangeRadius(n) {
          let b = this.options,
              e = this.options.seriesIndex,
              p = this.chart.series[e],
              a = b.ranges[0].value,
              s = b.ranges[b.ranges.length - 1].value,
              t = b.minSize,
              r = b.maxSize;
          return p.getRadius.call(this, s, a, t, r, n)
        }
        render() {
          let n = this.legendItem || {},
              b = this.chart.renderer,
              e = this.options.zThreshold;
          for (let p of (this.symbols || (this.symbols = {
            connectors: [],
            bubbleItems: [],
            labels: []
          }), n.symbol = b.g("bubble-legend"), n.label = b.g("bubble-legend-item").css(this.legend.itemStyle || {}), n.symbol.translateX = 0, n.symbol.translateY = 0, n.symbol.add(n.label), n.label.add(n.group), this.ranges)) p.value >= e && this.renderRange(p);
          this.hideOverlappingLabels()
        }
        renderRange(n) {
          let b = this.ranges[0],
              e = this.legend,
              p = this.options,
              a = p.labels,
              s = this.chart,
              t = s.series[p.seriesIndex],
              r = s.renderer,
              P = this.symbols,
              L = P.labels,
              B = n.center,
              S = Math.abs(n.radius),
              Y = p.connectorDistance || 0,
              X = a.align,
              C = e.options.rtl,
              i = p.borderWidth,
              o = p.connectorWidth,
              f = b.radius || 0,
              m = B - S - i / 2 + o / 2,
              w = (m % 1 ? 1 : .5) - (o % 2 ? 0 : .5),
              c = r.styledMode,
              A = C || X === "left" ? -Y : Y;
          X === "center" && (A = 0, p.connectorDistance = 0, n.labelAttribs.align = "center"), P.bubbleItems.push(r.circle(f, B + w, S).attr(c ? {} : n.bubbleAttribs).addClass((c ? "highcharts-color-" + t.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (p.className || "")).add(this.legendItem.symbol)), P.connectors.push(r.path(r.crispLine([
            ["M", f, m],
            ["L", f + A, m]
          ], p.connectorWidth)).attr(c ? {} : n.connectorAttribs).addClass((c ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (p.connectorClassName || "")).add(this.legendItem.symbol));
          let _ = r.text(this.formatLabel(n)).attr(c ? {} : n.labelAttribs).css(c ? {} : a.style).addClass("highcharts-bubble-legend-labels " + (p.labels.className || "")).add(this.legendItem.symbol),
              F = {
                x: f + A + p.labels.x,
                y: m + p.labels.y + .4 * _.getBBox().height
              };
          _.attr(F), L.push(_), _.placed = !0, _.alignAttr = F
        }
        getMaxLabelSize() {
          let n, b;
          return this.symbols.labels.forEach(function(e) {
            b = e.getBBox(!0), n = n ? b.width > n.width ? b : n : b
          }), n || {}
        }
        formatLabel(n) {
          let b = this.options,
              e = b.labels.formatter,
              p = b.labels.format,
              {
                numberFormatter: a
              } = this.chart;
          return p ? u.format(p, n) : e ? e.call(n) : a(n.value, 1)
        }
        hideOverlappingLabels() {
          let n = this.chart,
              b = this.options.labels.allowOverlap,
              e = this.symbols;
          !b && e && (n.hideOverlappingLabels(e.labels), e.labels.forEach(function(p, a) {
            p.newOpacity ? p.newOpacity !== p.oldOpacity && e.connectors[a].show() : e.connectors[a].hide()
          }))
        }
        getRanges() {
          let n = this.legend.bubbleLegend,
              b = n.chart.series,
              e = n.options.ranges,
              p, a, s = Number.MAX_VALUE,
              t = -Number.MAX_VALUE;
          return b.forEach(function(r) {
            r.isBubble && !r.ignoreSeries && (a = r.zData.filter(H)).length && (s = M(r.options.zMin, Math.min(s, Math.max(R(a), r.options.displayNegative === !1 ? r.options.zThreshold : -Number.MAX_VALUE))), t = M(r.options.zMax, Math.max(t, k(a))))
          }), p = s === t ? [{
            value: t
          }] : [{
            value: s
          }, {
            value: (s + t) / 2
          }, {
            value: t,
            autoRanges: !0
          }], e.length && e[0].radius && p.reverse(), p.forEach(function(r, P) {
            e && e[P] && (p[P] = I(e[P], r))
          }), p
        }
        predictBubbleSizes() {
          let n = this.chart,
              b = n.legend.options,
              e = b.floating,
              p = b.layout === "horizontal",
              a = p ? n.legend.lastLineHeight : 0,
              s = n.plotSizeX,
              t = n.plotSizeY,
              r = n.series[this.options.seriesIndex],
              P = r.getPxExtremes(),
              L = Math.ceil(P.minPxSize),
              B = Math.ceil(P.maxPxSize),
              S, Y = r.options.maxSize;
          return e || !/%$/.test(Y) ? S = B : (S = (Math.min(t, s) + a) * (Y = parseFloat(Y)) / 100 / (Y / 100 + 1), (p && t - S >= s || !p && s - S >= t) && (S = B)), [L, Math.ceil(S)]
        }
        updateRanges(n, b) {
          let e = this.legend.options.bubbleLegend;
          e.minSize = n, e.maxSize = b, e.ranges = this.getRanges()
        }
        correctSizes() {
          let n = this.legend,
              b = this.chart.series[this.options.seriesIndex].getPxExtremes();
          Math.abs(Math.ceil(b.maxPxSize) - this.options.maxSize) > 1 && (this.updateRanges(this.options.minSize, b.maxPxSize), n.render())
        }
      }
    }), ot(d, "Series/Bubble/BubbleLegendComposition.js", [d["Series/Bubble/BubbleLegendDefaults.js"], d["Series/Bubble/BubbleLegendItem.js"], d["Core/Defaults.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function(h, u, x, g, j) {
      let {
        setOptions: T
      } = x, {
        composed: k
      } = g, {
        addEvent: R,
        objectEach: H,
        pushUnique: I,
        wrap: M
      } = j;

      function y(s, t, r) {
        let P, L, B, S = this.legend,
            Y = n(this) >= 0;
        S && S.options.enabled && S.bubbleLegend && S.options.bubbleLegend.autoRanges && Y ? (P = S.bubbleLegend.options, L = S.bubbleLegend.predictBubbleSizes(), S.bubbleLegend.updateRanges(L[0], L[1]), P.placed || (S.group.placed = !1, S.allItems.forEach(X => {
          (B = X.legendItem || {}).group && (B.group.translateY = void 0)
        })), S.render(), this.getMargins(), this.axes.forEach(function(X) {
          X.visible && X.render(), P.placed || (X.setScale(), X.updateNames(), H(X.ticks, function(C) {
            C.isNew = !0, C.isNewLabel = !0
          }))
        }), P.placed = !0, this.getMargins(), s.call(this, t, r), S.bubbleLegend.correctSizes(), a(S, b(S))) : (s.call(this, t, r), S && S.options.enabled && S.bubbleLegend && (S.render(), a(S, b(S))))
      }

      function n(s) {
        let t = s.series,
            r = 0;
        for (; r < t.length;) {
          if (t[r] && t[r].isBubble && t[r].visible && t[r].zData.length) return r;
          r++
        }
        return -1
      }

      function b(s) {
        let t = s.allItems,
            r = [],
            P = t.length,
            L, B, S, Y = 0,
            X = 0;
        for (Y = 0; Y < P; Y++)
          if (B = t[Y].legendItem || {}, S = (t[Y + 1] || {}).legendItem || {}, B.labelHeight && (t[Y].itemHeight = B.labelHeight), t[Y] === t[P - 1] || B.y !== S.y) {
            for (r.push({
              height: 0
            }), L = r[r.length - 1]; X <= Y; X++) t[X].itemHeight > L.height && (L.height = t[X].itemHeight);
            L.step = Y
          } return r
      }

      function e(s) {
        let t = this.bubbleLegend,
            r = this.options,
            P = r.bubbleLegend,
            L = n(this.chart);
        t && t.ranges && t.ranges.length && (P.ranges.length && (P.autoRanges = !!P.ranges[0].autoRanges), this.destroyItem(t)), L >= 0 && r.enabled && P.enabled && (P.seriesIndex = L, this.bubbleLegend = new u(P, this), this.bubbleLegend.addToLegend(s.allItems))
      }

      function p(s) {
        let t;
        if (s.defaultPrevented) return !1;
        let r = this.chart,
            P = this.visible,
            L = this.chart.legend;
        L && L.bubbleLegend && (this.visible = !P, this.ignoreSeries = P, t = n(r) >= 0, L.bubbleLegend.visible !== t && (L.update({
          bubbleLegend: {
            enabled: t
          }
        }), L.bubbleLegend.visible = t), this.visible = P)
      }

      function a(s, t) {
        let r = s.allItems,
            P = s.options.rtl,
            L, B, S, Y, X = 0;
        r.forEach((C, i) => {
          (Y = C.legendItem || {}).group && (L = Y.group.translateX || 0, B = Y.y || 0, ((S = C.movementX) || P && C.ranges) && (S = P ? L - C.options.maxSize / 2 : L + S, Y.group.attr({
            translateX: S
          })), i > t[X].step && X++, Y.group.attr({
            translateY: Math.round(B + t[X].height / 2)
          }), Y.y = B + t[X].height / 2)
        })
      }
      return {
        compose: function(s, t, r) {
          I(k, "Series.BubbleLegend") && (T({
            legend: {
              bubbleLegend: h
            }
          }), M(s.prototype, "drawChartBox", y), R(t, "afterGetAllItems", e), R(r, "legendItemClick", p))
        }
      }
    }), ot(d, "Series/Bubble/BubblePoint.js", [d["Core/Series/Point.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x) {
      let {
        seriesTypes: {
          scatter: {
            prototype: {
              pointClass: g
            }
          }
        }
      } = u, {
        extend: j
      } = x;
      class T extends g {
        haloPath(R) {
          return h.prototype.haloPath.call(this, R === 0 ? 0 : (this.marker && this.marker.radius || 0) + R)
        }
      }
      return j(T.prototype, {
        ttBelow: !1
      }), T
    }), ot(d, "Series/Bubble/BubbleSeries.js", [d["Series/Bubble/BubbleLegendComposition.js"], d["Series/Bubble/BubblePoint.js"], d["Core/Color/Color.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x, g, j, T) {
      let {
        parse: k
      } = x, {
        composed: R,
        noop: H
      } = g, {
        series: I,
        seriesTypes: {
          column: {
            prototype: M
          },
          scatter: y
        }
      } = j, {
        addEvent: n,
        arrayMax: b,
        arrayMin: e,
        clamp: p,
        extend: a,
        isNumber: s,
        merge: t,
        pick: r,
        pushUnique: P
      } = T;

      function L() {
        let S = this.len,
            {
              coll: Y,
              isXAxis: X,
              min: C
            } = this,
            i = X ? "xData" : "yData",
            o = (this.max || 0) - (C || 0),
            f = 0,
            m = S,
            w = S / o,
            c;
        (Y === "xAxis" || Y === "yAxis") && (this.series.forEach(A => {
          if (A.bubblePadding && A.reserveSpace()) {
            this.allowZoomOutside = !0, c = !0;
            let _ = A[i];
            if (X && ((A.onPoint || A).getRadii(0, 0, A), A.onPoint && (A.radii = A.onPoint.radii)), o > 0) {
              let F = _.length;
              for (; F--;)
                if (s(_[F]) && this.dataMin <= _[F] && _[F] <= this.max) {
                  let tt = A.radii && A.radii[F] || 0;
                  f = Math.min((_[F] - C) * w - tt, f), m = Math.max((_[F] - C) * w + tt, m)
                }
            }
          }
        }), c && o > 0 && !this.logarithmic && (m -= S, w *= (S + Math.max(0, f) - Math.min(m, S)) / S, [
          ["min", "userMin", f],
          ["max", "userMax", m]
        ].forEach(A => {
          r(this.options[A[0]], this[A[1]]) === void 0 && (this[A[0]] += A[2] / w)
        })))
      }
      class B extends y {
        static compose(Y, X, C, i) {
          h.compose(X, C, i), P(R, "Series.Bubble") && n(Y, "foundExtremes", L)
        }
        animate(Y) {
          !Y && this.points.length < this.options.animationLimit && this.points.forEach(function(X) {
            let {
              graphic: C
            } = X;
            C && C.width && (this.hasRendered || C.attr({
              x: X.plotX,
              y: X.plotY,
              width: 1,
              height: 1
            }), C.animate(this.markerAttribs(X), this.options.animation))
          }, this)
        }
        getRadii() {
          let Y = this.zData,
              X = this.yData,
              C = [],
              i, o, f, m = this.chart.bubbleZExtremes,
              {
                minPxSize: w,
                maxPxSize: c
              } = this.getPxExtremes();
          if (!m) {
            let A, _ = Number.MAX_VALUE,
                F = -Number.MAX_VALUE;
            this.chart.series.forEach(tt => {
              if (tt.bubblePadding && tt.reserveSpace()) {
                let J = (tt.onPoint || tt).getZExtremes();
                J && (_ = Math.min(r(_, J.zMin), J.zMin), F = Math.max(r(F, J.zMax), J.zMax), A = !0)
              }
            }), A ? (m = {
              zMin: _,
              zMax: F
            }, this.chart.bubbleZExtremes = m) : m = {
              zMin: 0,
              zMax: 0
            }
          }
          for (o = 0, i = Y.length; o < i; o++) f = Y[o], C.push(this.getRadius(m.zMin, m.zMax, w, c, f, X && X[o]));
          this.radii = C
        }
        getRadius(Y, X, C, i, o, f) {
          let m = this.options,
              w = m.sizeBy !== "width",
              c = m.zThreshold,
              A = X - Y,
              _ = .5;
          if (f === null || o === null) return null;
          if (s(o)) {
            if (m.sizeByAbsoluteValue && (o = Math.abs(o - c), X = A = Math.max(X - c, Math.abs(Y - c)), Y = 0), o < Y) return C / 2 - 1;
            A > 0 && (_ = (o - Y) / A)
          }
          return w && _ >= 0 && (_ = Math.sqrt(_)), Math.ceil(C + _ * (i - C)) / 2
        }
        hasData() {
          return !!this.processedXData.length
        }
        pointAttribs(Y, X) {
          let C = this.options.marker.fillOpacity,
              i = I.prototype.pointAttribs.call(this, Y, X);
          return C !== 1 && (i.fill = k(i.fill).setOpacity(C).get("rgba")), i
        }
        translate() {
          super.translate.call(this), this.getRadii(), this.translateBubble()
        }
        translateBubble() {
          let {
            data: Y,
            options: X,
            radii: C
          } = this, {
            minPxSize: i
          } = this.getPxExtremes(), o = Y.length;
          for (; o--;) {
            let f = Y[o],
                m = C ? C[o] : 0;
            this.zoneAxis === "z" && (f.negative = (f.z || 0) < (X.zThreshold || 0)), s(m) && m >= i / 2 ? (f.marker = a(f.marker, {
              radius: m,
              width: 2 * m,
              height: 2 * m
            }), f.dlBox = {
              x: f.plotX - m,
              y: f.plotY - m,
              width: 2 * m,
              height: 2 * m
            }) : (f.shapeArgs = f.plotY = f.dlBox = void 0, f.isInside = !1)
          }
        }
        getPxExtremes() {
          let Y = Math.min(this.chart.plotWidth, this.chart.plotHeight),
              X = o => {
                let f;
                return typeof o == "string" && (f = /%$/.test(o), o = parseInt(o, 10)), f ? Y * o / 100 : o
              },
              C = X(r(this.options.minSize, 8)),
              i = Math.max(X(r(this.options.maxSize, "20%")), C);
          return {
            minPxSize: C,
            maxPxSize: i
          }
        }
        getZExtremes() {
          let Y = this.options,
              X = (this.zData || []).filter(s);
          if (X.length) {
            let C = r(Y.zMin, p(e(X), Y.displayNegative === !1 ? Y.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE)),
                i = r(Y.zMax, b(X));
            if (s(C) && s(i)) return {
              zMin: C,
              zMax: i
            }
          }
        }
      }
      return B.defaultOptions = t(y.defaultOptions, {
        dataLabels: {
          formatter: function() {
            let {
              numberFormatter: S
            } = this.series.chart, {
              z: Y
            } = this.point;
            return s(Y) ? S(Y, -1) : ""
          },
          inside: !0,
          verticalAlign: "middle"
        },
        animationLimit: 250,
        marker: {
          lineColor: null,
          lineWidth: 1,
          fillOpacity: .5,
          radius: null,
          states: {
            hover: {
              radiusPlus: 0
            }
          },
          symbol: "circle"
        },
        minSize: 8,
        maxSize: "20%",
        softThreshold: !1,
        states: {
          hover: {
            halo: {
              size: 5
            }
          }
        },
        tooltip: {
          pointFormat: "({point.x}, {point.y}), Size: {point.z}"
        },
        turboThreshold: 0,
        zThreshold: 0,
        zoneAxis: "z"
      }), a(B.prototype, {
        alignDataLabel: M.alignDataLabel,
        applyZones: H,
        bubblePadding: !0,
        isBubble: !0,
        pointArrayMap: ["y", "z"],
        pointClass: u,
        parallelArrays: ["x", "y", "z"],
        trackerGroups: ["group", "dataLabelsGroup"],
        specialGroup: "group",
        zoneAxis: "z"
      }), n(B, "updatedData", S => {
        delete S.target.chart.bubbleZExtremes
      }), n(B, "remove", S => {
        delete S.target.chart.bubbleZExtremes
      }), j.registerSeriesType("bubble", B), B
    }), ot(d, "Series/ColumnRange/ColumnRangePoint.js", [d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u) {
      let {
        seriesTypes: {
          column: {
            prototype: {
              pointClass: {
                prototype: x
              }
            }
          },
          arearange: {
            prototype: {
              pointClass: g
            }
          }
        }
      } = h, {
        extend: j,
        isNumber: T
      } = u;
      class k extends g {
        isValid() {
          return T(this.low)
        }
      }
      return j(k.prototype, {
        setState: x.setState
      }), k
    }), ot(d, "Series/ColumnRange/ColumnRangeSeries.js", [d["Series/ColumnRange/ColumnRangePoint.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x, g) {
      let {
        noop: j
      } = u, {
        seriesTypes: {
          arearange: T,
          column: k,
          column: {
            prototype: R
          }
        }
      } = x, {
        addEvent: H,
        clamp: I,
        extend: M,
        isNumber: y,
        merge: n,
        pick: b
      } = g;
      class e extends T {
        setOptions() {
          return n(!0, arguments[0], {
            stacking: void 0
          }), T.prototype.setOptions.apply(this, arguments)
        }
        translate() {
          return R.translate.apply(this)
        }
        pointAttribs() {
          return R.pointAttribs.apply(this, arguments)
        }
        translate3dPoints() {
          return R.translate3dPoints.apply(this, arguments)
        }
        translate3dShapes() {
          return R.translate3dShapes.apply(this, arguments)
        }
        afterColumnTranslate() {
          let a, s, t, r, P = this.yAxis,
              L = this.xAxis,
              B = L.startAngleRad,
              S = this.chart,
              Y = this.xAxis.isRadial,
              X = Math.max(S.chartWidth, S.chartHeight) + 999;
          this.points.forEach(C => {
            let i = C.shapeArgs || {},
                o = this.options.minPointLength,
                f = C.plotY,
                m = P.translate(C.high, 0, 1, 0, 1);
            if (y(m) && y(f))
              if (C.plotHigh = I(m, -X, X), C.plotLow = I(f, -X, X), r = C.plotHigh, Math.abs(a = b(C.rectPlotY, C.plotY) - C.plotHigh) < o ? (s = o - a, a += s, r -= s / 2) : a < 0 && (a *= -1, r -= a), Y && this.polar) t = C.barX + B, C.shapeType = "arc", C.shapeArgs = this.polar.arc(r + a, r, t, t + C.pointWidth);
              else {
                i.height = a, i.y = r;
                let {
                  x: w = 0,
                  width: c = 0
                } = i;
                C.shapeArgs = n(C.shapeArgs, this.crispCol(w, r, c, a)), C.tooltipPos = S.inverted ? [P.len + P.pos - S.plotLeft - r - a / 2, L.len + L.pos - S.plotTop - w - c / 2, a] : [L.left - S.plotLeft + w + c / 2, P.pos - S.plotTop + r + a / 2, a]
              }
          })
        }
      }
      return e.defaultOptions = n(k.defaultOptions, T.defaultOptions, {
        borderRadius: {
          where: "all"
        },
        pointRange: null,
        legendSymbol: "rectangle",
        marker: null,
        states: {
          hover: {
            halo: !1
          }
        }
      }), H(e, "afterColumnTranslate", function() {
        e.prototype.afterColumnTranslate.apply(this)
      }, {
        order: 5
      }), M(e.prototype, {
        directTouch: !0,
        pointClass: h,
        trackerGroups: ["group", "dataLabelsGroup"],
        adjustForMissingColumns: R.adjustForMissingColumns,
        animate: R.animate,
        crispCol: R.crispCol,
        drawGraph: j,
        drawPoints: R.drawPoints,
        getSymbol: j,
        drawTracker: R.drawTracker,
        getColumnMetrics: R.getColumnMetrics
      }), x.registerSeriesType("columnrange", e), e
    }), ot(d, "Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js", [], function() {
      return {}
    }), ot(d, "Series/ColumnPyramid/ColumnPyramidSeries.js", [d["Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x) {
      let {
        column: g
      } = u.seriesTypes, {
        clamp: j,
        merge: T,
        pick: k
      } = x;
      class R extends g {
        translate() {
          let I = this.chart,
              M = this.options,
              y = this.dense = this.closestPointRange * this.xAxis.transA < 2,
              n = this.borderWidth = k(M.borderWidth, y ? 0 : 1),
              b = this.yAxis,
              e = M.threshold,
              p = k(M.minPointLength, 5),
              a = this.getColumnMetrics(),
              s = a.width,
              t = this.pointXOffset = a.offset,
              r = this.translatedThreshold = b.getThreshold(e),
              P = this.barW = Math.max(s, 1 + 2 * n);
          for (let L of (I.inverted && (r -= .5), M.pointPadding && (P = Math.ceil(P)), super.translate(), this.points)) {
            let B = k(L.yBottom, r),
                S = 999 + Math.abs(B),
                Y = j(L.plotY, -S, b.len + S),
                X = P / 2,
                C = Math.min(Y, B),
                i = Math.max(Y, B) - C,
                o = L.plotX + t,
                f, m, w, c, A, _, F, tt, J, U, l, N;
            M.centerInCategory && (o = this.adjustForMissingColumns(o, s, L, a)), L.barX = o, L.pointWidth = s, L.tooltipPos = I.inverted ? [b.len + b.pos - I.plotLeft - Y, this.xAxis.len - o - X, i] : [o + X, Y + b.pos - I.plotTop, i], f = e + (L.total || L.y), M.stacking === "percent" && (f = e + (L.y < 0) ? -100 : 100), w = b.toPixels(f, !0), c = (m = I.plotHeight - w - (I.plotHeight - r)) ? X * (C - w) / m : 0, A = m ? X * (C + i - w) / m : 0, F = o - c + X, tt = o + c + X, J = o + A + X, U = o - A + X, l = C - p, N = C + i, L.y < 0 && (l = C, N = C + i + p), I.inverted && (_ = b.width - C, m = w - (b.width - r), c = X * (w - _) / m, A = X * (w - (_ - i)) / m, tt = (F = o + X + c) - 2 * c, J = o - A + X, U = o + A + X, l = C, N = C + i - p, L.y < 0 && (N = C + i + p)), L.shapeType = "path", L.shapeArgs = {
              x: F,
              y: l,
              width: tt - F,
              height: i,
              d: [
                ["M", F, l],
                ["L", tt, l],
                ["L", J, N],
                ["L", U, N],
                ["Z"]
              ]
            }
          }
        }
      }
      return R.defaultOptions = T(g.defaultOptions, h), u.registerSeriesType("columnpyramid", R), R
    }), ot(d, "Series/ErrorBar/ErrorBarSeriesDefaults.js", [], function() {
      return {
        color: "#000000",
        grouping: !1,
        linkedTo: ":previous",
        tooltip: {
          pointFormat: '<span style="color:{point.color}">鈼�</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
        },
        whiskerWidth: null
      }
    }), ot(d, "Series/ErrorBar/ErrorBarSeries.js", [d["Series/BoxPlot/BoxPlotSeries.js"], d["Series/Column/ColumnSeries.js"], d["Series/ErrorBar/ErrorBarSeriesDefaults.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x, g, j) {
      let {
        arearange: T
      } = g.seriesTypes, {
        addEvent: k,
        merge: R,
        extend: H
      } = j;
      class I extends h {
        getColumnMetrics() {
          return this.linkedParent && this.linkedParent.columnMetrics || u.prototype.getColumnMetrics.call(this)
        }
        drawDataLabels() {
          let y = this.pointValKey;
          if (T)
            for (let n of (T.prototype.drawDataLabels.call(this), this.points)) n.y = n[y]
        }
        toYData(y) {
          return [y.low, y.high]
        }
      }
      return I.defaultOptions = R(h.defaultOptions, x), k(I, "afterTranslate", function() {
        for (let M of this.points) M.plotLow = M.plotY
      }, {
        order: 0
      }), H(I.prototype, {
        pointArrayMap: ["low", "high"],
        pointValKey: "high",
        doQuartiles: !1
      }), g.registerSeriesType("errorbar", I), I
    }), ot(d, "Series/Gauge/GaugePoint.js", [d["Core/Series/SeriesRegistry.js"]], function(h) {
      let {
        series: {
          prototype: {
            pointClass: u
          }
        }
      } = h;
      return class extends u {
        setState(x) {
          this.state = x
        }
      }
    }), ot(d, "Series/Gauge/GaugeSeries.js", [d["Series/Gauge/GaugePoint.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x, g) {
      let {
        noop: j
      } = u, {
        series: T,
        seriesTypes: {
          column: k
        }
      } = x, {
        clamp: R,
        isNumber: H,
        extend: I,
        merge: M,
        pick: y,
        pInt: n,
        defined: b
      } = g;
      class e extends T {
        translate() {
          let a = this.yAxis,
              s = this.options,
              t = a.center;
          this.generatePoints(), this.points.forEach(r => {
            let P = M(s.dial, r.dial),
                L = n(P.radius) * t[2] / 200,
                B = n(P.baseLength) * L / 100,
                S = n(P.rearLength) * L / 100,
                Y = P.baseWidth,
                X = P.topWidth,
                C = s.overshoot,
                i = a.startAngleRad + a.translate(r.y, void 0, void 0, void 0, !0);
            (H(C) || s.wrap === !1) && (C = H(C) ? C / 180 * Math.PI : 0, i = R(i, a.startAngleRad - C, a.endAngleRad + C)), i = 180 * i / Math.PI, r.shapeType = "path";
            let o = P.path || [
              ["M", -S, -Y / 2],
              ["L", B, -Y / 2],
              ["L", L, -X / 2],
              ["L", L, X / 2],
              ["L", B, Y / 2],
              ["L", -S, Y / 2],
              ["Z"]
            ];
            r.shapeArgs = {
              d: o,
              translateX: t[0],
              translateY: t[1],
              rotation: i
            }, r.plotX = t[0], r.plotY = t[1], b(r.y) && a.max - a.min && (r.percentage = (r.y - a.min) / (a.max - a.min) * 100)
          })
        }
        drawPoints() {
          let a = this,
              s = a.chart,
              t = a.yAxis.center,
              r = a.pivot,
              P = a.options,
              L = P.pivot,
              B = s.renderer;
          a.points.forEach(S => {
            let Y = S.graphic,
                X = S.shapeArgs,
                C = X.d,
                i = M(P.dial, S.dial);
            Y ? (Y.animate(X), X.d = C) : S.graphic = B[S.shapeType](X).addClass("highcharts-dial").add(a.group), s.styledMode || S.graphic[Y ? "animate" : "attr"]({
              stroke: i.borderColor,
              "stroke-width": i.borderWidth,
              fill: i.backgroundColor
            })
          }), r ? r.animate({
            translateX: t[0],
            translateY: t[1]
          }) : L && (a.pivot = B.circle(0, 0, L.radius).attr({
            zIndex: 2
          }).addClass("highcharts-pivot").translate(t[0], t[1]).add(a.group), s.styledMode || a.pivot.attr({
            fill: L.backgroundColor,
            stroke: L.borderColor,
            "stroke-width": L.borderWidth
          }))
        }
        animate(a) {
          let s = this;
          a || s.points.forEach(t => {
            let r = t.graphic;
            r && (r.attr({
              rotation: 180 * s.yAxis.startAngleRad / Math.PI
            }), r.animate({
              rotation: t.shapeArgs.rotation
            }, s.options.animation))
          })
        }
        render() {
          this.group = this.plotGroup("group", "series", this.visible ? "inherit" : "hidden", this.options.zIndex, this.chart.seriesGroup), T.prototype.render.call(this), this.group.clip(this.chart.clipRect)
        }
        setData(a, s) {
          T.prototype.setData.call(this, a, !1), this.processData(), this.generatePoints(), y(s, !0) && this.chart.redraw()
        }
        hasData() {
          return !!this.points.length
        }
      }
      return e.defaultOptions = M(T.defaultOptions, {
        dataLabels: {
          borderColor: "#cccccc",
          borderRadius: 3,
          borderWidth: 1,
          crop: !1,
          defer: !1,
          enabled: !0,
          verticalAlign: "top",
          y: 15,
          zIndex: 2
        },
        dial: {
          backgroundColor: "#000000",
          baseLength: "70%",
          baseWidth: 3,
          borderColor: "#cccccc",
          borderWidth: 0,
          radius: "80%",
          rearLength: "10%",
          topWidth: 1
        },
        pivot: {
          radius: 5,
          borderWidth: 0,
          borderColor: "#cccccc",
          backgroundColor: "#000000"
        },
        tooltip: {
          headerFormat: ""
        },
        showInLegend: !1
      }), I(e.prototype, {
        angular: !0,
        directTouch: !0,
        drawGraph: j,
        drawTracker: k.prototype.drawTracker,
        fixedBox: !0,
        forceDL: !0,
        noSharedTooltip: !0,
        pointClass: h,
        trackerGroups: ["group", "dataLabelsGroup"]
      }), x.registerSeriesType("gauge", e), e
    }), ot(d, "Series/DragNodesComposition.js", [d["Core/Globals.js"], d["Core/Utilities.js"]], function(h, u) {
      let {
        composed: x
      } = h, {
        addEvent: g,
        pushUnique: j
      } = u;

      function T() {
        let k, R, H, I = this;
        I.container && (k = g(I.container, "mousedown", M => {
          let y = I.hoverPoint;
          y && y.series && y.series.hasDraggableNodes && y.series.options.draggable && (y.series.onMouseDown(y, M), R = g(I.container, "mousemove", n => y && y.series && y.series.onMouseMove(y, n)), H = g(I.container.ownerDocument, "mouseup", n => (R(), H(), y && y.series && y.series.onMouseUp(y, n))))
        })), g(I, "destroy", function() {
          k()
        })
      }
      return {
        compose: function(k) {
          j(x, "DragNodes") && g(k, "load", T)
        },
        onMouseDown: function(k, R) {
          var I;
          let H = ((I = this.chart.pointer) == null ? void 0 : I.normalize(R)) || R;
          k.fixedPosition = {
            chartX: H.chartX,
            chartY: H.chartY,
            plotX: k.plotX,
            plotY: k.plotY
          }, k.inDragMode = !0
        },
        onMouseMove: function(k, R) {
          var H;
          if (k.fixedPosition && k.inDragMode) {
            let I, M, y = this.chart,
                n = ((H = y.pointer) == null ? void 0 : H.normalize(R)) || R,
                b = k.fixedPosition.chartX - n.chartX,
                e = k.fixedPosition.chartY - n.chartY,
                p = y.graphLayoutsLookup;
            (Math.abs(b) > 5 || Math.abs(e) > 5) && (I = k.fixedPosition.plotX - b, M = k.fixedPosition.plotY - e, y.isInsidePlot(I, M) && (k.plotX = I, k.plotY = M, k.hasDragged = !0, this.redrawHalo(k), p.forEach(a => {
              a.restartSimulation()
            })))
          }
        },
        onMouseUp: function(k) {
          k.fixedPosition && (k.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), k.inDragMode = k.hasDragged = !1, this.options.fixedDraggable || delete k.fixedPosition)
        },
        redrawHalo: function(k) {
          k && this.halo && this.halo.attr({
            d: k.haloPath(this.options.states.hover.halo.size)
          })
        }
      }
    }), ot(d, "Series/GraphLayoutComposition.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function(h, u, x) {
      let {
        setAnimation: g
      } = h, {
        composed: j
      } = u, {
        addEvent: T,
        pushUnique: k
      } = x;

      function R() {
        this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(y => {
          y.updateSimulation()
        }), this.redraw())
      }

      function H() {
        this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(y => {
          y.updateSimulation(!1)
        }), this.redraw())
      }

      function I() {
        this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(y => {
          y.stop()
        })
      }

      function M() {
        let y, n = !1,
            b = e => {
              e.maxIterations-- && isFinite(e.temperature) && !e.isStable() && !e.enableSimulation && (e.beforeStep && e.beforeStep(), e.step(), y = !1, n = !0)
            };
        if (this.graphLayoutsLookup) {
          for (g(!1, this), this.graphLayoutsLookup.forEach(e => e.start()); !y;) y = !0, this.graphLayoutsLookup.forEach(b);
          n && this.series.forEach(e => {
            e && e.layout && e.render()
          })
        }
      }
      return {
        compose: function(y) {
          k(j, "GraphLayout") && (T(y, "afterPrint", R), T(y, "beforePrint", H), T(y, "predraw", I), T(y, "render", M))
        },
        integrations: {},
        layouts: {}
      }
    }), ot(d, "Series/PackedBubble/PackedBubblePoint.js", [d["Core/Chart/Chart.js"], d["Core/Series/Point.js"], d["Core/Series/SeriesRegistry.js"]], function(h, u, x) {
      let {
        seriesTypes: {
          bubble: {
            prototype: {
              pointClass: g
            }
          }
        }
      } = x;
      return class extends g {
        destroy() {
          return this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes), u.prototype.destroy.apply(this, arguments)
        }
        firePointEvent() {
          let j = this.series.options;
          if (this.isParentNode && j.parentNode) {
            let T = j.allowPointSelect;
            j.allowPointSelect = j.parentNode.allowPointSelect, u.prototype.firePointEvent.apply(this, arguments), j.allowPointSelect = T
          } else u.prototype.firePointEvent.apply(this, arguments)
        }
        select() {
          let j = this.series.chart;
          this.isParentNode ? (j.getSelectedPoints = j.getSelectedParentNodes, u.prototype.select.apply(this, arguments), j.getSelectedPoints = h.prototype.getSelectedPoints) : u.prototype.select.apply(this, arguments)
        }
      }
    }), ot(d, "Series/PackedBubble/PackedBubbleSeriesDefaults.js", [d["Core/Utilities.js"]], function(h) {
      let {
        isNumber: u
      } = h;
      return {
        minSize: "10%",
        maxSize: "50%",
        sizeBy: "area",
        zoneAxis: "y",
        crisp: !1,
        tooltip: {
          pointFormat: "Value: {point.value}"
        },
        draggable: !0,
        useSimulation: !0,
        parentNode: {
          allowPointSelect: !1
        },
        dataLabels: {
          formatter: function() {
            let {
              numberFormatter: x
            } = this.series.chart, {
              value: g
            } = this.point;
            return u(g) ? x(g, -1) : ""
          },
          parentNodeFormatter: function() {
            return this.name
          },
          parentNodeTextPath: {
            enabled: !0
          },
          padding: 0,
          style: {
            transition: "opacity 2000ms"
          }
        },
        layoutAlgorithm: {
          initialPositions: "circle",
          initialPositionRadius: 20,
          bubblePadding: 5,
          parentNodeLimit: !1,
          seriesInteraction: !0,
          dragBetweenSeries: !1,
          parentNodeOptions: {
            maxIterations: 400,
            gravitationalConstant: .03,
            maxSpeed: 50,
            initialPositionRadius: 100,
            seriesInteraction: !0,
            marker: {
              fillColor: null,
              fillOpacity: 1,
              lineWidth: null,
              lineColor: null,
              symbol: "circle"
            }
          },
          enableSimulation: !0,
          type: "packedbubble",
          integration: "packedbubble",
          maxIterations: 1e3,
          splitSeries: !1,
          maxSpeed: 5,
          gravitationalConstant: .01,
          friction: -.981
        }
      }
    }), ot(d, "Series/Networkgraph/VerletIntegration.js", [], function() {
      return {
        attractive: function(h, u, x) {
          let g = h.getMass(),
              j = -x.x * u * this.diffTemperature,
              T = -x.y * u * this.diffTemperature;
          h.fromNode.fixedPosition || (h.fromNode.plotX -= j * g.fromNode / h.fromNode.degree, h.fromNode.plotY -= T * g.fromNode / h.fromNode.degree), h.toNode.fixedPosition || (h.toNode.plotX += j * g.toNode / h.toNode.degree, h.toNode.plotY += T * g.toNode / h.toNode.degree)
        },
        attractiveForceFunction: function(h, u) {
          return (u - h) / h
        },
        barycenter: function() {
          let h = this.options.gravitationalConstant,
              u = this.barycenter.xFactor,
              x = this.barycenter.yFactor;
          u = (u - (this.box.left + this.box.width) / 2) * h, x = (x - (this.box.top + this.box.height) / 2) * h, this.nodes.forEach(function(g) {
            g.fixedPosition || (g.plotX -= u / g.mass / g.degree, g.plotY -= x / g.mass / g.degree)
          })
        },
        getK: function(h) {
          return Math.pow(h.box.width * h.box.height / h.nodes.length, .5)
        },
        integrate: function(h, u) {
          let x = -h.options.friction,
              g = h.options.maxSpeed,
              j = u.prevX,
              T = u.prevY,
              k = (u.plotX + u.dispX - j) * x,
              R = (u.plotY + u.dispY - T) * x,
              H = Math.abs,
              I = H(k) / (k || 1),
              M = H(R) / (R || 1);
          k = I * Math.min(g, Math.abs(k)), R = M * Math.min(g, Math.abs(R)), u.prevX = u.plotX + u.dispX, u.prevY = u.plotY + u.dispY, u.plotX += k, u.plotY += R, u.temperature = h.vectorLength({
            x: k,
            y: R
          })
        },
        repulsive: function(h, u, x) {
          let g = u * this.diffTemperature / h.mass / h.degree;
          h.fixedPosition || (h.plotX += x.x * g, h.plotY += x.y * g)
        },
        repulsiveForceFunction: function(h, u) {
          return (u - h) / h * (u > h ? 1 : 0)
        }
      }
    }), ot(d, "Series/PackedBubble/PackedBubbleIntegration.js", [d["Core/Globals.js"], d["Series/Networkgraph/VerletIntegration.js"]], function(h, u) {
      let {
        noop: x
      } = h;
      return {
        barycenter: function() {
          let g, j, T = this.options.gravitationalConstant,
              k = this.box,
              R = this.nodes;
          for (let H of R) this.options.splitSeries && !H.isParentNode ? (g = H.series.parentNode.plotX, j = H.series.parentNode.plotY) : (g = k.width / 2, j = k.height / 2), H.fixedPosition || (H.plotX -= (H.plotX - g) * T / (H.mass * Math.sqrt(R.length)), H.plotY -= (H.plotY - j) * T / (H.mass * Math.sqrt(R.length)))
        },
        getK: x,
        integrate: u.integrate,
        repulsive: function(g, j, T, k) {
          let R = j * this.diffTemperature / g.mass / g.degree,
              H = T.x * R,
              I = T.y * R;
          g.fixedPosition || (g.plotX += H, g.plotY += I), k.fixedPosition || (k.plotX -= H, k.plotY -= I)
        },
        repulsiveForceFunction: function(g, j, T, k) {
          return Math.min(g, (T.marker.radius + k.marker.radius) / 2)
        }
      }
    }), ot(d, "Series/Networkgraph/EulerIntegration.js", [], function() {
      return {
        attractive: function(h, u, x, g) {
          let j = h.getMass(),
              T = x.x / g * u,
              k = x.y / g * u;
          h.fromNode.fixedPosition || (h.fromNode.dispX -= T * j.fromNode / h.fromNode.degree, h.fromNode.dispY -= k * j.fromNode / h.fromNode.degree), h.toNode.fixedPosition || (h.toNode.dispX += T * j.toNode / h.toNode.degree, h.toNode.dispY += k * j.toNode / h.toNode.degree)
        },
        attractiveForceFunction: function(h, u) {
          return h * h / u
        },
        barycenter: function() {
          let h = this.options.gravitationalConstant,
              u = this.barycenter.xFactor,
              x = this.barycenter.yFactor;
          this.nodes.forEach(function(g) {
            if (!g.fixedPosition) {
              let j = g.getDegree(),
                  T = j * (1 + j / 2);
              g.dispX += (u - g.plotX) * h * T / g.degree, g.dispY += (x - g.plotY) * h * T / g.degree
            }
          })
        },
        getK: function(h) {
          return Math.pow(h.box.width * h.box.height / h.nodes.length, .3)
        },
        integrate: function(h, u) {
          let x;
          u.dispX += u.dispX * h.options.friction, u.dispY += u.dispY * h.options.friction, (x = u.temperature = h.vectorLength({
            x: u.dispX,
            y: u.dispY
          })) !== 0 && (u.plotX += u.dispX / x * Math.min(Math.abs(u.dispX), h.temperature), u.plotY += u.dispY / x * Math.min(Math.abs(u.dispY), h.temperature))
        },
        repulsive: function(h, u, x, g) {
          h.dispX += x.x / g * u / h.degree, h.dispY += x.y / g * u / h.degree
        },
        repulsiveForceFunction: function(h, u) {
          return u * u / h
        }
      }
    }), ot(d, "Series/Networkgraph/QuadTreeNode.js", [], function() {
      class h {
        constructor(x) {
          this.body = !1, this.isEmpty = !1, this.isInternal = !1, this.nodes = [], this.box = x, this.boxSize = Math.min(x.width, x.height)
        }
        divideBox() {
          let x = this.box.width / 2,
              g = this.box.height / 2;
          this.nodes[0] = new h({
            left: this.box.left,
            top: this.box.top,
            width: x,
            height: g
          }), this.nodes[1] = new h({
            left: this.box.left + x,
            top: this.box.top,
            width: x,
            height: g
          }), this.nodes[2] = new h({
            left: this.box.left + x,
            top: this.box.top + g,
            width: x,
            height: g
          }), this.nodes[3] = new h({
            left: this.box.left,
            top: this.box.top + g,
            width: x,
            height: g
          })
        }
        getBoxPosition(x) {
          let g = x.plotX < this.box.left + this.box.width / 2,
              j = x.plotY < this.box.top + this.box.height / 2;
          return g ? j ? 0 : 3 : j ? 1 : 2
        }
        insert(x, g) {
          let j;
          this.isInternal ? this.nodes[this.getBoxPosition(x)].insert(x, g - 1) : (this.isEmpty = !1, this.body ? g ? (this.isInternal = !0, this.divideBox(), this.body !== !0 && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, g - 1), this.body = !0), this.nodes[this.getBoxPosition(x)].insert(x, g - 1)) : ((j = new h({
            top: x.plotX || NaN,
            left: x.plotY || NaN,
            width: .1,
            height: .1
          })).body = x, j.isInternal = !1, this.nodes.push(j)) : (this.isInternal = !1, this.body = x))
        }
        updateMassAndCenter() {
          let x = 0,
              g = 0,
              j = 0;
          if (this.isInternal) {
            for (let T of this.nodes) T.isEmpty || (x += T.mass, g += T.plotX * T.mass, j += T.plotY * T.mass);
            g /= x, j /= x
          } else this.body && (x = this.body.mass, g = this.body.plotX, j = this.body.plotY);
          this.mass = x, this.plotX = g, this.plotY = j
        }
      }
      return h
    }), ot(d, "Series/Networkgraph/QuadTree.js", [d["Series/Networkgraph/QuadTreeNode.js"]], function(h) {
      return class {
        constructor(u, x, g, j) {
          this.box = {
            left: u,
            top: x,
            width: g,
            height: j
          }, this.maxDepth = 25, this.root = new h(this.box), this.root.isInternal = !0, this.root.isRoot = !0, this.root.divideBox()
        }
        calculateMassAndCenter() {
          this.visitNodeRecursive(null, null, function(u) {
            u.updateMassAndCenter()
          })
        }
        insertNodes(u) {
          for (let x of u) this.root.insert(x, this.maxDepth)
        }
        visitNodeRecursive(u, x, g) {
          let j;
          if (u || (u = this.root), u === this.root && x && (j = x(u)), j !== !1) {
            for (let T of u.nodes) {
              if (T.isInternal) {
                if (x && (j = x(T)), j === !1) continue;
                this.visitNodeRecursive(T, x, g)
              } else T.body && x && x(T.body);
              g && g(T)
            }
            u === this.root && g && g(u)
          }
        }
      }
    }), ot(d, "Series/Networkgraph/ReingoldFruchtermanLayout.js", [d["Series/Networkgraph/EulerIntegration.js"], d["Core/Globals.js"], d["Series/GraphLayoutComposition.js"], d["Series/Networkgraph/QuadTree.js"], d["Core/Utilities.js"], d["Series/Networkgraph/VerletIntegration.js"]], function(h, u, x, g, j, T) {
      let {
        win: k
      } = u, {
        clamp: R,
        defined: H,
        isFunction: I,
        fireEvent: M,
        pick: y
      } = j;
      class n {
        constructor() {
          this.box = {}, this.currentStep = 0, this.initialRendering = !0, this.links = [], this.nodes = [], this.series = [], this.simulation = !1
        }
        static compose(e) {
          x.compose(e), x.integrations.euler = h, x.integrations.verlet = T, x.layouts["reingold-fruchterman"] = n
        }
        init(e) {
          this.options = e, this.nodes = [], this.links = [], this.series = [], this.box = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          }, this.setInitialRendering(!0), this.integration = x.integrations[e.integration], this.enableSimulation = e.enableSimulation, this.attractiveForce = y(e.attractiveForce, this.integration.attractiveForceFunction), this.repulsiveForce = y(e.repulsiveForce, this.integration.repulsiveForceFunction), this.approximation = e.approximation
        }
        updateSimulation(e) {
          this.enableSimulation = y(e, this.options.enableSimulation)
        }
        start() {
          let e = this.series,
              p = this.options;
          this.currentStep = 0, this.forces = e[0] && e[0].forces || [], this.chart = e[0] && e[0].chart, this.initialRendering && (this.initPositions(), e.forEach(function(a) {
            a.finishedAnimating = !0, a.render()
          })), this.setK(), this.resetSimulation(p), this.enableSimulation && this.step()
        }
        step() {
          let e = this.series;
          for (let p of (this.currentStep++, this.approximation === "barnes-hut" && (this.createQuadTree(), this.quadTree.calculateMassAndCenter()), this.forces || [])) this[p + "Forces"](this.temperature);
          if (this.applyLimits(), this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep), this.prevSystemTemperature = this.systemTemperature, this.systemTemperature = this.getSystemTemperature(), this.enableSimulation) {
            for (let p of e) p.chart && p.render();
            this.maxIterations-- && isFinite(this.temperature) && !this.isStable() ? (this.simulation && k.cancelAnimationFrame(this.simulation), this.simulation = k.requestAnimationFrame(() => this.step())) : (this.simulation = !1, this.series.forEach(p => {
              M(p, "afterSimulation")
            }))
          }
        }
        stop() {
          this.simulation && k.cancelAnimationFrame(this.simulation)
        }
        setArea(e, p, a, s) {
          this.box = {
            left: e,
            top: p,
            width: a,
            height: s
          }
        }
        setK() {
          this.k = this.options.linkLength || this.integration.getK(this)
        }
        addElementsToCollection(e, p) {
          for (let a of e) p.indexOf(a) === -1 && p.push(a)
        }
        removeElementFromCollection(e, p) {
          let a = p.indexOf(e);
          a !== -1 && p.splice(a, 1)
        }
        clear() {
          this.nodes.length = 0, this.links.length = 0, this.series.length = 0, this.resetSimulation()
        }
        resetSimulation() {
          this.forcedStop = !1, this.systemTemperature = 0, this.setMaxIterations(), this.setTemperature(), this.setDiffTemperature()
        }
        restartSimulation() {
          this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0))
        }
        setMaxIterations(e) {
          this.maxIterations = y(e, this.options.maxIterations)
        }
        setTemperature() {
          this.temperature = this.startTemperature = Math.sqrt(this.nodes.length)
        }
        setDiffTemperature() {
          this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1)
        }
        setInitialRendering(e) {
          this.initialRendering = e
        }
        createQuadTree() {
          this.quadTree = new g(this.box.left, this.box.top, this.box.width, this.box.height), this.quadTree.insertNodes(this.nodes)
        }
        initPositions() {
          let e = this.options.initialPositions;
          if (I(e))
            for (let p of (e.call(this), this.nodes)) H(p.prevX) || (p.prevX = p.plotX), H(p.prevY) || (p.prevY = p.plotY), p.dispX = 0, p.dispY = 0;
          else e === "circle" ? this.setCircularPositions() : this.setRandomPositions()
        }
        setCircularPositions() {
          let e, p = this.box,
              a = this.nodes,
              s = 2 * Math.PI / (a.length + 1),
              t = a.filter(function(S) {
                return S.linksTo.length === 0
              }),
              r = {},
              P = this.options.initialPositionRadius,
              L = S => {
                for (let Y of S.linksFrom || []) r[Y.toNode.id] || (r[Y.toNode.id] = !0, B.push(Y.toNode), L(Y.toNode))
              },
              B = [];
          for (let S of t) B.push(S), L(S);
          if (B.length)
            for (let S of a) B.indexOf(S) === -1 && B.push(S);
          else B = a;
          for (let S = 0, Y = B.length; S < Y; ++S)(e = B[S]).plotX = e.prevX = y(e.plotX, p.width / 2 + P * Math.cos(S * s)), e.plotY = e.prevY = y(e.plotY, p.height / 2 + P * Math.sin(S * s)), e.dispX = 0, e.dispY = 0
        }
        setRandomPositions() {
          let e, p = this.box,
              a = this.nodes,
              s = a.length + 1,
              t = r => {
                let P = r * r / Math.PI;
                return P - Math.floor(P)
              };
          for (let r = 0, P = a.length; r < P; ++r)(e = a[r]).plotX = e.prevX = y(e.plotX, p.width * t(r)), e.plotY = e.prevY = y(e.plotY, p.height * t(s + r)), e.dispX = 0, e.dispY = 0
        }
        force(e, ...p) {
          this.integration[e].apply(this, p)
        }
        barycenterForces() {
          this.getBarycenter(), this.force("barycenter")
        }
        getBarycenter() {
          let e = 0,
              p = 0,
              a = 0;
          for (let s of this.nodes) p += s.plotX * s.mass, a += s.plotY * s.mass, e += s.mass;
          return this.barycenter = {
            x: p,
            y: a,
            xFactor: p / e,
            yFactor: a / e
          }, this.barycenter
        }
        barnesHutApproximation(e, p) {
          let a, s, t = this.getDistXY(e, p),
              r = this.vectorLength(t);
          return e !== p && r !== 0 && (p.isInternal ? p.boxSize / r < this.options.theta && r !== 0 ? (s = this.repulsiveForce(r, this.k), this.force("repulsive", e, s * p.mass, t, r), a = !1) : a = !0 : (s = this.repulsiveForce(r, this.k), this.force("repulsive", e, s * p.mass, t, r))), a
        }
        repulsiveForces() {
          if (this.approximation === "barnes-hut")
            for (let e of this.nodes) this.quadTree.visitNodeRecursive(null, p => this.barnesHutApproximation(e, p));
          else {
            let e, p, a;
            for (let s of this.nodes)
              for (let t of this.nodes) s === t || s.fixedPosition || (a = this.getDistXY(s, t), (p = this.vectorLength(a)) !== 0 && (e = this.repulsiveForce(p, this.k), this.force("repulsive", s, e * t.mass, a, p)))
          }
        }
        attractiveForces() {
          let e, p, a;
          for (let s of this.links) s.fromNode && s.toNode && (e = this.getDistXY(s.fromNode, s.toNode), (p = this.vectorLength(e)) !== 0 && (a = this.attractiveForce(p, this.k), this.force("attractive", s, a, e, p)))
        }
        applyLimits() {
          for (let e of this.nodes) {
            if (e.fixedPosition) return;
            this.integration.integrate(this, e), this.applyLimitBox(e, this.box), e.dispX = 0, e.dispY = 0
          }
        }
        applyLimitBox(e, p) {
          let a = e.radius;
          e.plotX = R(e.plotX, p.left + a, p.width - a), e.plotY = R(e.plotY, p.top + a, p.height - a)
        }
        coolDown(e, p, a) {
          return e - p * a
        }
        isStable() {
          return 1e-5 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || this.temperature <= 0
        }
        getSystemTemperature() {
          let e = 0;
          for (let p of this.nodes) e += p.temperature;
          return e
        }
        vectorLength(e) {
          return Math.sqrt(e.x * e.x + e.y * e.y)
        }
        getDistR(e, p) {
          let a = this.getDistXY(e, p);
          return this.vectorLength(a)
        }
        getDistXY(e, p) {
          let a = e.plotX - p.plotX,
              s = e.plotY - p.plotY;
          return {
            x: a,
            y: s,
            absX: Math.abs(a),
            absY: Math.abs(s)
          }
        }
      }
      return n
    }), ot(d, "Series/PackedBubble/PackedBubbleLayout.js", [d["Series/GraphLayoutComposition.js"], d["Series/PackedBubble/PackedBubbleIntegration.js"], d["Series/Networkgraph/ReingoldFruchtermanLayout.js"], d["Core/Utilities.js"]], function(h, u, x, g) {
      let {
        addEvent: j,
        pick: T
      } = g;

      function k() {
        let I = this.series,
            M = [];
        return I.forEach(y => {
          y.parentNode && y.parentNode.selected && M.push(y.parentNode)
        }), M
      }

      function R() {
        this.allDataPoints && delete this.allDataPoints
      }
      class H extends x {
        constructor() {
          super(...arguments), this.index = NaN, this.nodes = [], this.series = []
        }
        static compose(M) {
          x.compose(M), h.integrations.packedbubble = u, h.layouts.packedbubble = H;
          let y = M.prototype;
          y.getSelectedParentNodes || (j(M, "beforeRedraw", R), y.getSelectedParentNodes = k)
        }
        beforeStep() {
          this.options.marker && this.series.forEach(M => {
            M && M.calculateParentRadius()
          })
        }
        isStable() {
          let M = Math.abs(this.prevSystemTemperature - this.systemTemperature);
          return 1 > Math.abs(10 * this.systemTemperature / Math.sqrt(this.nodes.length)) && M < 1e-5 || this.temperature <= 0
        }
        setCircularPositions() {
          let M = this.box,
              y = this.nodes,
              n = 2 * Math.PI / (y.length + 1),
              b = this.options.initialPositionRadius,
              e, p, a = 0;
          for (let s of y) this.options.splitSeries && !s.isParentNode ? (e = s.series.parentNode.plotX, p = s.series.parentNode.plotY) : (e = M.width / 2, p = M.height / 2), s.plotX = s.prevX = T(s.plotX, e + b * Math.cos(s.index || a * n)), s.plotY = s.prevY = T(s.plotY, p + b * Math.sin(s.index || a * n)), s.dispX = 0, s.dispY = 0, a++
        }
        repulsiveForces() {
          let M, y, n, b = this,
              e = b.options.bubblePadding;
          b.nodes.forEach(p => {
            p.degree = p.mass, p.neighbours = 0, b.nodes.forEach(a => {
              M = 0, p !== a && !p.fixedPosition && (b.options.seriesInteraction || p.series === a.series) && (n = b.getDistXY(p, a), (y = b.vectorLength(n) - (p.marker.radius + a.marker.radius + e)) < 0 && (p.degree += .01, p.neighbours++, M = b.repulsiveForce(-y / Math.sqrt(p.neighbours), b.k, p, a)), b.force("repulsive", p, M * a.mass, n, a, y))
            })
          })
        }
        applyLimitBox(M, y) {
          let n, b;
          this.options.splitSeries && !M.isParentNode && this.options.parentNodeLimit && (n = this.getDistXY(M, M.series.parentNode), (b = M.series.parentNodeRadius - M.marker.radius - this.vectorLength(n)) < 0 && b > -2 * M.marker.radius && (M.plotX -= .01 * n.x, M.plotY -= .01 * n.y)), super.applyLimitBox(M, y)
        }
      }
      return h.layouts.packedbubble = H, H
    }), ot(d, "Series/SimulationSeriesUtilities.js", [d["Core/Utilities.js"], d["Core/Animation/AnimationUtilities.js"]], function(h, u) {
      let {
        merge: x,
        syncTimeout: g
      } = h, {
        animObject: j
      } = u;
      return {
        initDataLabels: function() {
          let T = this.options.dataLabels;
          if (!this.dataLabelsGroup) {
            let k = this.initDataLabelsGroup();
            return !this.chart.styledMode && (T != null && T.style) && k.css(T.style), k.attr({
              opacity: 0
            }), this.visible && k.show(), k
          }
          return this.dataLabelsGroup.attr(x({
            opacity: 1
          }, this.getPlotBox("data-labels"))), this.dataLabelsGroup
        },
        initDataLabelsDefer: function() {
          var k;
          let T = this.options.dataLabels;
          T != null && T.defer && ((k = this.options.layoutAlgorithm) != null && k.enableSimulation) ? g(() => {
            this.deferDataLabels = !1
          }, T ? j(T.animation).defer : 0) : this.deferDataLabels = !1
        }
      }
    }), ot(d, "Series/PackedBubble/PackedBubbleSeries.js", [d["Core/Color/Color.js"], d["Series/DragNodesComposition.js"], d["Series/GraphLayoutComposition.js"], d["Core/Globals.js"], d["Series/PackedBubble/PackedBubblePoint.js"], d["Series/PackedBubble/PackedBubbleSeriesDefaults.js"], d["Series/PackedBubble/PackedBubbleLayout.js"], d["Core/Series/SeriesRegistry.js"], d["Series/SimulationSeriesUtilities.js"], d["Core/Utilities.js"]], function(h, u, x, g, j, T, k, R, H, I) {
      let {
        parse: M
      } = h, {
        noop: y
      } = g, {
        series: {
          prototype: n
        },
        seriesTypes: {
          bubble: b
        }
      } = R, {
        initDataLabels: e,
        initDataLabelsDefer: p
      } = H, {
        addEvent: a,
        clamp: s,
        defined: t,
        extend: r,
        fireEvent: P,
        isArray: L,
        isNumber: B,
        merge: S,
        pick: Y
      } = I;
      class X extends b {
        constructor() {
          super(...arguments), this.parentNodeMass = 0, this.deferDataLabels = !0
        }
        static compose(i, o, f, m) {
          b.compose(i, o, f, m), u.compose(o), k.compose(o)
        }
        accumulateAllPoints() {
          let i, o = this.chart,
              f = [];
          for (let m of o.series)
            if (m.is("packedbubble") && m.reserveSpace()) {
              i = m.yData || [];
              for (let w = 0; w < i.length; w++) f.push([null, null, i[w], m.index, w, {
                id: w,
                marker: {
                  radius: 0
                }
              }])
            } return f
        }
        addLayout() {
          let i = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},
              o = i.type || "packedbubble",
              f = this.chart.options.chart,
              m = this.chart.graphLayoutsStorage,
              w = this.chart.graphLayoutsLookup,
              c;
          m || (this.chart.graphLayoutsStorage = m = {}, this.chart.graphLayoutsLookup = w = []), (c = m[o]) || (i.enableSimulation = t(f.forExport) ? !f.forExport : i.enableSimulation, m[o] = c = new x.layouts[o], c.init(i), w.splice(c.index, 0, c)), this.layout = c, this.points.forEach(A => {
            A.mass = 2, A.degree = 1, A.collisionNmb = 1
          }), c.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight), c.addElementsToCollection([this], c.series), c.addElementsToCollection(this.points, c.nodes)
        }
        addSeriesLayout() {
          let i = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {},
              o = i.type || "packedbubble",
              f = this.chart.graphLayoutsStorage,
              m = this.chart.graphLayoutsLookup,
              w = S(i, i.parentNodeOptions, {
                enableSimulation: this.layout.options.enableSimulation
              }),
              c = f[o + "-series"];
          c || (f[o + "-series"] = c = new x.layouts[o], c.init(w), m.splice(c.index, 0, c)), this.parentNodeLayout = c, this.createParentNodes()
        }
        calculateParentRadius() {
          let i = this.seriesBox();
          this.parentNodeRadius = s(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, i ? Math.max(Math.sqrt(Math.pow(i.width, 2) + Math.pow(i.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20), this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius)
        }
        calculateZExtremes() {
          let i = this.chart.series,
              o = this.options.zMin,
              f = this.options.zMax,
              m = 1 / 0,
              w = -1 / 0;
          return o && f ? [o, f] : (i.forEach(c => {
            c.yData.forEach(A => {
              t(A) && (A > w && (w = A), A < m && (m = A))
            })
          }), [o = Y(o, m), f = Y(f, w)])
        }
        checkOverlap(i, o) {
          let f = i[0] - o[0],
              m = i[1] - o[1];
          return Math.sqrt(f * f + m * m) - Math.abs(i[2] + o[2]) < -.001
        }
        createParentNodes() {
          let i = this.pointClass,
              o = this.chart,
              f = this.parentNodeLayout,
              m = this.layout.options,
              w, c = this.parentNode,
              A = {
                radius: this.parentNodeRadius,
                lineColor: this.color,
                fillColor: M(this.color).brighten(.4).get()
              };
          m.parentNodeOptions && (A = S(m.parentNodeOptions.marker || {}, A)), this.parentNodeMass = 0, this.points.forEach(_ => {
            this.parentNodeMass += Math.PI * Math.pow(_.marker.radius, 2)
          }), this.calculateParentRadius(), f.nodes.forEach(_ => {
            _.seriesIndex === this.index && (w = !0)
          }), f.setArea(0, 0, o.plotWidth, o.plotHeight), w || (c || (c = new i(this, {
            mass: this.parentNodeRadius / 2,
            marker: A,
            dataLabels: {
              inside: !1
            },
            states: {
              normal: {
                marker: A
              },
              hover: {
                marker: A
              }
            },
            dataLabelOnNull: !0,
            degree: this.parentNodeRadius,
            isParentNode: !0,
            seriesIndex: this.index
          })), this.parentNode && (c.plotX = this.parentNode.plotX, c.plotY = this.parentNode.plotY), this.parentNode = c, f.addElementsToCollection([this], f.series), f.addElementsToCollection([c], f.nodes))
        }
        deferLayout() {
          let i = this.options.layoutAlgorithm;
          this.visible && (this.addLayout(), i.splitSeries && this.addSeriesLayout())
        }
        destroy() {
          this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(i => {
            i.removeElementFromCollection(this, i.series)
          }, this), this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy())), n.destroy.apply(this, arguments)
        }
        drawDataLabels() {
          !this.deferDataLabels && (n.drawDataLabels.call(this, this.points), this.parentNode && (this.parentNode.formatPrefix = "parentNode", n.drawDataLabels.call(this, [this.parentNode])))
        }
        drawGraph() {
          var w;
          if (!this.layout || !this.layout.options.splitSeries) return;
          let i = this.chart,
              o = this.layout.options.parentNodeOptions.marker,
              f = {
                fill: o.fillColor || M(this.color).brighten(.4).get(),
                opacity: o.fillOpacity,
                stroke: o.lineColor || this.color,
                "stroke-width": Y(o.lineWidth, this.options.lineWidth)
              },
              m = {};
          this.parentNodesGroup = this.plotGroup("parentNodesGroup", "parentNode", this.visible ? "inherit" : "hidden", .1, i.seriesGroup), (w = this.group) == null || w.attr({
            zIndex: 2
          }), this.calculateParentRadius(), this.parentNode && t(this.parentNode.plotX) && t(this.parentNode.plotY) && t(this.parentNodeRadius) && (m = S({
            x: this.parentNode.plotX - this.parentNodeRadius,
            y: this.parentNode.plotY - this.parentNodeRadius,
            width: 2 * this.parentNodeRadius,
            height: 2 * this.parentNodeRadius
          }, f), this.parentNode.graphic || (this.graph = this.parentNode.graphic = i.renderer.symbol(f.symbol).add(this.parentNodesGroup)), this.parentNode.graphic.attr(m))
        }
        drawTracker() {
          let i, o = this.parentNode;
          super.drawTracker(), o && (i = L(o.dataLabels) ? o.dataLabels : o.dataLabel ? [o.dataLabel] : [], o.graphic && (o.graphic.element.point = o), i.forEach(f => {
            (f.div || f.element).point = o
          }))
        }
        getPointRadius() {
          let i, o, f, m, w = this.chart,
              c = w.plotWidth,
              A = w.plotHeight,
              _ = this.options,
              F = _.useSimulation,
              tt = Math.min(c, A),
              J = {},
              U = [],
              l = w.allDataPoints || [],
              N = l.length;
          ["minSize", "maxSize"].forEach(O => {
            let z = parseInt(_[O], 10),
                Z = /%$/.test(_[O]);
            J[O] = Z ? tt * z / 100 : z * Math.sqrt(N)
          }), w.minRadius = i = J.minSize / Math.sqrt(N), w.maxRadius = o = J.maxSize / Math.sqrt(N);
          let V = F ? this.calculateZExtremes() : [i, o];
          l.forEach((O, z) => {
            f = F ? s(O[2], V[0], V[1]) : O[2], (m = this.getRadius(V[0], V[1], i, o, f)) === 0 && (m = null), l[z][2] = m, U.push(m)
          }), this.radii = U
        }
        init() {
          return n.init.apply(this, arguments), p.call(this), this.eventsToUnbind.push(a(this, "updatedData", function() {
            this.chart.series.forEach(i => {
              i.type === this.type && (i.isDirty = !0)
            }, this)
          })), this
        }
        onMouseUp(i) {
          if (i.fixedPosition && !i.removed) {
            let o, f = this.layout,
                m = this.parentNodeLayout;
            m && f.options.dragBetweenSeries && m.nodes.forEach(w => {
              i && i.marker && w !== i.series.parentNode && (o = f.getDistXY(i, w), f.vectorLength(o) - w.marker.radius - i.marker.radius < 0 && (w.series.addPoint(S(i.options, {
                plotX: i.plotX,
                plotY: i.plotY
              }), !1), f.removeElementFromCollection(i, f.nodes), i.remove()))
            }), u.onMouseUp.apply(this, arguments)
          }
        }
        placeBubbles(i) {
          let o = this.checkOverlap,
              f = this.positionBubble,
              m = [],
              w = 1,
              c = 0,
              A = 0,
              _, F = [],
              tt, J = i.sort((U, l) => l[2] - U[2]);
          if (J.length) {
            if (m.push([
              [0, 0, J[0][2], J[0][3], J[0][4]]
            ]), J.length > 1)
              for (m.push([
                [0, 0 - J[1][2] - J[0][2], J[1][2], J[1][3], J[1][4]]
              ]), tt = 2; tt < J.length; tt++) J[tt][2] = J[tt][2] || 1, o(_ = f(m[w][c], m[w - 1][A], J[tt]), m[w][0]) ? (m.push([]), A = 0, m[w + 1].push(f(m[w][c], m[w][0], J[tt])), w++, c = 0) : w > 1 && m[w - 1][A + 1] && o(_, m[w - 1][A + 1]) ? (A++, m[w].push(f(m[w][c], m[w - 1][A], J[tt])), c++) : (c++, m[w].push(_));
            this.chart.stages = m, this.chart.rawPositions = [].concat.apply([], m), this.resizeRadius(), F = this.chart.rawPositions
          }
          return F
        }
        pointAttribs(i, o) {
          let f = this.options,
              m = i && i.isParentNode,
              w = f.marker;
          m && f.layoutAlgorithm && f.layoutAlgorithm.parentNodeOptions && (w = f.layoutAlgorithm.parentNodeOptions.marker);
          let c = w.fillOpacity,
              A = n.pointAttribs.call(this, i, o);
          return c !== 1 && (A["fill-opacity"] = c), A
        }
        positionBubble(i, o, f) {
          let m = Math.pow,
              w = (0, Math.sqrt)(m(i[0] - o[0], 2) + m(i[1] - o[1], 2)),
              c = (0, Math.acos)((m(w, 2) + m(f[2] + o[2], 2) - m(f[2] + i[2], 2)) / (2 * (f[2] + o[2]) * w)),
              A = (0, Math.asin)((0, Math.abs)(i[0] - o[0]) / w),
              _ = (i[1] - o[1] < 0 ? 0 : Math.PI) + c + A * ((i[0] - o[0]) * (i[1] - o[1]) < 0 ? 1 : -1);
          return [o[0] + (o[2] + f[2]) * Math.sin(_), o[1] - (o[2] + f[2]) * Math.cos(_), f[2], f[3], f[4]]
        }
        render() {
          let i = [];
          n.render.apply(this, arguments), !this.options.dataLabels.allowOverlap && (this.data.forEach(o => {
            L(o.dataLabels) && o.dataLabels.forEach(f => {
              i.push(f)
            })
          }), this.options.useSimulation && this.chart.hideOverlappingLabels(i))
        }
        resizeRadius() {
          let i, o, f, m, w, c = this.chart,
              A = c.rawPositions,
              _ = Math.min,
              F = Math.max,
              tt = c.plotLeft,
              J = c.plotTop,
              U = c.plotHeight,
              l = c.plotWidth;
          for (let z of (i = f = Number.POSITIVE_INFINITY, o = m = Number.NEGATIVE_INFINITY, A)) w = z[2], i = _(i, z[0] - w), o = F(o, z[0] + w), f = _(f, z[1] - w), m = F(m, z[1] + w);
          let N = [o - i, m - f],
              V = [(l - tt) / N[0], (U - J) / N[1]],
              O = _.apply([], V);
          if (Math.abs(O - 1) > 1e-10) {
            for (let z of A) z[2] *= O;
            this.placeBubbles(A)
          } else c.diffY = U / 2 + J - f - (m - f) / 2, c.diffX = l / 2 + tt - i - (o - i) / 2
        }
        seriesBox() {
          let i, o = this.chart,
              f = this.data,
              m = Math.max,
              w = Math.min,
              c = [o.plotLeft, o.plotLeft + o.plotWidth, o.plotTop, o.plotTop + o.plotHeight];
          return f.forEach(A => {
            t(A.plotX) && t(A.plotY) && A.marker.radius && (i = A.marker.radius, c[0] = w(c[0], A.plotX - i), c[1] = m(c[1], A.plotX + i), c[2] = w(c[2], A.plotY - i), c[3] = m(c[3], A.plotY + i))
          }), B(c.width / c.height) ? c : null
        }
        setVisible() {
          let i = this;
          n.setVisible.apply(i, arguments), i.parentNodeLayout && i.graph ? i.visible ? (i.graph.show(), i.parentNode.dataLabel && i.parentNode.dataLabel.show()) : (i.graph.hide(), i.parentNodeLayout.removeElementFromCollection(i.parentNode, i.parentNodeLayout.nodes), i.parentNode.dataLabel && i.parentNode.dataLabel.hide()) : i.layout && (i.visible ? i.layout.addElementsToCollection(i.points, i.layout.nodes) : i.points.forEach(o => {
            i.layout.removeElementFromCollection(o, i.layout.nodes)
          }))
        }
        translate() {
          let i, o, f, m = this.chart,
              w = this.data,
              c = this.index,
              A = this.options.useSimulation;
          for (let _ of (this.processedXData = this.xData, this.generatePoints(), t(m.allDataPoints) || (m.allDataPoints = this.accumulateAllPoints(), this.getPointRadius()), A ? f = m.allDataPoints : (f = this.placeBubbles(m.allDataPoints), this.options.draggable = !1), f)) _[3] === c && (i = w[_[4]], o = Y(_[2], void 0), A || (i.plotX = _[0] - m.plotLeft + m.diffX, i.plotY = _[1] - m.plotTop + m.diffY), B(o) && (i.marker = r(i.marker, {
            radius: o,
            width: 2 * o,
            height: 2 * o
          }), i.radius = o));
          A && this.deferLayout(), P(this, "afterTranslate")
        }
      }
      return X.defaultOptions = S(b.defaultOptions, T), r(X.prototype, {
        pointClass: j,
        axisTypes: [],
        directTouch: !0,
        forces: ["barycenter", "repulsive"],
        hasDraggableNodes: !0,
        invertible: !1,
        isCartesian: !1,
        noSharedTooltip: !0,
        pointArrayMap: ["value"],
        pointValKey: "value",
        requireSorting: !1,
        trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"],
        initDataLabels: e,
        alignDataLabel: n.alignDataLabel,
        indexateNodes: y,
        onMouseDown: u.onMouseDown,
        onMouseMove: u.onMouseMove,
        redrawHalo: u.redrawHalo,
        searchPoint: y
      }), R.registerSeriesType("packedbubble", X), X
    }), ot(d, "Series/Polygon/PolygonSeriesDefaults.js", [], function() {
      return {
        marker: {
          enabled: !1,
          states: {
            hover: {
              enabled: !1
            }
          }
        },
        stickyTracking: !1,
        tooltip: {
          followPointer: !0,
          pointFormat: ""
        },
        trackByArea: !0,
        legendSymbol: "rectangle"
      }
    }), ot(d, "Series/Polygon/PolygonSeries.js", [d["Core/Globals.js"], d["Series/Polygon/PolygonSeriesDefaults.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(h, u, x, g) {
      let {
        noop: j
      } = h, {
        area: T,
        line: k,
        scatter: R
      } = x.seriesTypes, {
        extend: H,
        merge: I
      } = g;
      class M extends R {
        getGraphPath() {
          let n = k.prototype.getGraphPath.call(this),
              b = n.length + 1;
          for (; b--;)(b === n.length || n[b][0] === "M") && b > 0 && n.splice(b, 0, ["Z"]);
          return this.areaPath = n, n
        }
        drawGraph() {
          this.options.fillColor = this.color, T.prototype.drawGraph.call(this)
        }
      }
      return M.defaultOptions = I(R.defaultOptions, u), H(M.prototype, {
        type: "polygon",
        drawTracker: k.prototype.drawTracker,
        setStackedPoints: j
      }), x.registerSeriesType("polygon", M), M
    }), ot(d, "Core/Axis/RadialAxis.js", [d["Core/Defaults.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function(h, u, x) {
      var g;
      let {
        defaultOptions: j
      } = h, {
        composed: T,
        noop: k
      } = u, {
        addEvent: R,
        correctFloat: H,
        defined: I,
        extend: M,
        fireEvent: y,
        isObject: n,
        merge: b,
        pick: e,
        pushUnique: p,
        relativeLength: a,
        wrap: s
      } = x;
      return function(t) {
        let r = {
              gridLineWidth: 1,
              labels: {
                align: void 0,
                x: 0,
                y: void 0,
                style: {
                  textOverflow: "none"
                }
              },
              maxPadding: 0,
              minPadding: 0,
              showLastLabel: !1,
              tickLength: 0
            },
            P = {
              endOnTick: !1,
              gridLineWidth: 0,
              labels: {
                align: "center",
                distance: -25,
                x: 0,
                y: void 0
              },
              lineWidth: 1,
              minorGridLineWidth: 0,
              minorTickInterval: "auto",
              minorTickLength: 10,
              minorTickPosition: "inside",
              minorTickWidth: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickPosition: "inside",
              tickWidth: 2,
              title: {
                rotation: 0,
                text: ""
              },
              zIndex: 2
            },
            L = {
              gridLineInterpolation: "circle",
              gridLineWidth: 1,
              labels: {
                align: "right",
                x: -3,
                y: -2
              },
              showLastLabel: !1,
              title: {
                x: 4,
                text: null,
                rotation: 90
              }
            };

        function B() {
          this.autoConnect = this.isCircular && e(this.userMax, this.options.max) === void 0 && H(this.endAngleRad - this.startAngleRad) === H(2 * Math.PI), !this.isCircular && this.chart.inverted && this.max++, this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0)
        }

        function S() {
          return () => {
            if (this.isRadial && this.tickPositions && this.options.labels && this.options.labels.allowOverlap !== !0) return this.tickPositions.map(v => this.ticks[v] && this.ticks[v].label).filter(v => !!v)
          }
        }

        function Y() {
          return k
        }

        function X(v, D, E) {
          let W = this.pane.center,
              q = v.value,
              G, K, Q;
          return this.isCircular ? (I(q) ? v.point && (v.point.shapeArgs || {}).start && (q = this.chart.inverted ? this.translate(v.point.rectPlotY, !0) : v.point.x) : (K = v.chartX || 0, Q = v.chartY || 0, q = this.translate(Math.atan2(Q - E, K - D) - this.startAngleRad, !0)), K = (G = this.getPosition(q)).x, Q = G.y) : (I(q) || (K = v.chartX, Q = v.chartY), I(K) && I(Q) && (E = W[1] + this.chart.plotTop, q = this.translate(Math.min(Math.sqrt(Math.pow(K - D, 2) + Math.pow(Q - E, 2)), W[2] / 2) - W[3] / 2, !0))), [q, K || 0, Q || 0]
        }

        function C(v, D, E) {
          let W = this.pane.center,
              q = this.chart,
              G = this.left || 0,
              K = this.top || 0,
              Q, $ = e(D, W[2] / 2 - this.offset),
              it;
          return E === void 0 && (E = this.horiz ? 0 : this.center && -this.center[3] / 2), E && ($ += E), this.isCircular || D !== void 0 ? ((it = this.chart.renderer.symbols.arc(G + W[0], K + W[1], $, $, {
            start: this.startAngleRad,
            end: this.endAngleRad,
            open: !0,
            innerR: 0
          })).xBounds = [G + W[0]], it.yBounds = [K + W[1] - $]) : (Q = this.postTranslate(this.angleRad, $), it = [
            ["M", this.center[0] + q.plotLeft, this.center[1] + q.plotTop],
            ["L", Q.x, Q.y]
          ]), it
        }

        function i() {
          this.constructor.prototype.getOffset.call(this), this.chart.axisOffset[this.side] = 0
        }

        function o(v, D, E) {
          let W = this.chart,
              q = ft => {
                if (typeof ft == "string") {
                  let Pt = parseInt(ft, 10);
                  return ht.test(ft) && (Pt = Pt * Q / 100), Pt
                }
                return ft
              },
              G = this.center,
              K = this.startAngleRad,
              Q = G[2] / 2,
              $ = Math.min(this.offset, 0),
              it = this.left || 0,
              at = this.top || 0,
              ht = /%$/,
              rt = this.isCircular,
              et, nt, lt, dt, xt, ut, bt = e(q(E.outerRadius), Q),
              ct = q(E.innerRadius),
              mt = e(q(E.thickness), 10);
          if (this.options.gridLineInterpolation === "polygon") ut = this.getPlotLinePath({
            value: v
          }).concat(this.getPlotLinePath({
            value: D,
            reverse: !0
          }));
          else {
            v = Math.max(v, this.min), D = Math.min(D, this.max);
            let ft = this.translate(v),
                Pt = this.translate(D);
            rt || (bt = ft || 0, ct = Pt || 0), E.shape !== "circle" && rt ? (et = K + (ft || 0), nt = K + (Pt || 0)) : (et = -Math.PI / 2, nt = 1.5 * Math.PI, xt = !0), bt -= $, mt -= $, ut = W.renderer.symbols.arc(it + G[0], at + G[1], bt, bt, {
              start: Math.min(et, nt),
              end: Math.max(et, nt),
              innerR: e(ct, bt - mt),
              open: xt
            }), rt && (lt = (nt + et) / 2, dt = it + G[0] + G[2] / 2 * Math.cos(lt), ut.xBounds = lt > -Math.PI / 2 && lt < Math.PI / 2 ? [dt, W.plotWidth] : [0, dt], ut.yBounds = [at + G[1] + G[2] / 2 * Math.sin(lt)], ut.yBounds[0] += lt > -Math.PI && lt < 0 || lt > Math.PI ? -10 : 10)
          }
          return ut
        }

        function f(v) {
          let D = this.pane.center,
              E = this.chart,
              W = E.inverted,
              q = v.reverse,
              G = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {},
              K = G.innerRadius || "0%",
              Q = G.outerRadius || "100%",
              $ = D[0] + E.plotLeft,
              it = D[1] + E.plotTop,
              at = this.height,
              ht = v.isCrosshair,
              rt = D[3] / 2,
              et = v.value,
              nt, lt, dt, xt, ut, bt, ct, mt, ft, Pt = this.getPosition(et),
              St = Pt.x,
              Mt = Pt.y;
          if (ht && (et = (mt = this.getCrosshairPosition(v, $, it))[0], St = mt[1], Mt = mt[2]), this.isCircular) lt = Math.sqrt(Math.pow(St - $, 2) + Math.pow(Mt - it, 2)), dt = typeof K == "string" ? a(K, 1) : K / lt, xt = typeof Q == "string" ? a(Q, 1) : Q / lt, D && rt && (dt < (nt = rt / lt) && (dt = nt), xt < nt && (xt = nt)), ft = [
            ["M", $ + dt * (St - $), it - dt * (it - Mt)],
            ["L", St - (1 - xt) * (St - $), Mt + (1 - xt) * (it - Mt)]
          ];
          else if ((et = this.translate(et)) && (et < 0 || et > at) && (et = 0), this.options.gridLineInterpolation === "circle") ft = this.getLinePath(0, et, rt);
          else if (ft = [], E[W ? "yAxis" : "xAxis"].forEach(vt => {
            vt.pane === this.pane && (ut = vt)
          }), ut) {
            ct = ut.tickPositions, ut.autoConnect && (ct = ct.concat([ct[0]])), q && (ct = ct.slice().reverse()), et && (et += rt);
            for (let vt = 0; vt < ct.length; vt++) bt = ut.getPosition(ct[vt], et), ft.push(vt ? ["L", bt.x, bt.y] : ["M", bt.x, bt.y])
          }
          return ft
        }

        function m(v, D) {
          let E = this.translate(v);
          return this.postTranslate(this.isCircular ? E : this.angleRad, e(this.isCircular ? D : E < 0 ? 0 : E, this.center[2] / 2) - this.offset)
        }

        function w() {
          let v = this.center,
              D = this.chart,
              E = this.options.title;
          return {
            x: D.plotLeft + v[0] + (E.x || 0),
            y: D.plotTop + v[1] - {
              high: .5,
              middle: .25,
              low: 0
            } [E.align] * v[2] + (E.y || 0)
          }
        }

        function c(v) {
          v.beforeSetTickPositions = B, v.createLabelCollector = S, v.getCrosshairPosition = X, v.getLinePath = C, v.getOffset = i, v.getPlotBandPath = o, v.getPlotLinePath = f, v.getPosition = m, v.getTitlePosition = w, v.postTranslate = N, v.setAxisSize = O, v.setAxisTranslation = z, v.setOptions = Z
        }

        function A() {
          let v = this.chart,
              D = this.options,
              E = v.angular && this.isXAxis,
              W = this.pane,
              q = W && W.options;
          if (!E && W && (v.angular || v.polar)) {
            let G = 2 * Math.PI,
                K = (e(q.startAngle, 0) - 90) * Math.PI / 180,
                Q = (e(q.endAngle, e(q.startAngle, 0) + 360) - 90) * Math.PI / 180;
            this.angleRad = (D.angle || 0) * Math.PI / 180, this.startAngleRad = K, this.endAngleRad = Q, this.offset = D.offset || 0;
            let $ = (K % G + G) % G,
                it = (Q % G + G) % G;
            $ > Math.PI && ($ -= G), it > Math.PI && (it -= G), this.normalizedStartAngleRad = $, this.normalizedEndAngleRad = it
          }
        }

        function _(v) {
          this.isRadial && (v.align = void 0, v.preventDefault())
        }

        function F() {
          if (this.chart && this.chart.labelCollectors) {
            let v = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;
            v >= 0 && this.chart.labelCollectors.splice(v, 1)
          }
        }

        function tt(v) {
          let D, E = this.chart,
              W = E.angular,
              q = E.polar,
              G = this.isXAxis,
              K = this.coll,
              Q = v.userOptions.pane || 0,
              $ = this.pane = E.pane && E.pane[Q];
          if (K === "colorAxis") {
            this.isRadial = !1;
            return
          }
          W ? (W && G ? (this.isHidden = !0, this.createLabelCollector = Y, this.getOffset = k, this.redraw = V, this.render = V, this.setScale = k, this.setCategories = k, this.setTitle = k) : c(this), D = !G) : q && (c(this), D = this.horiz), W || q ? (this.isRadial = !0, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && E.labelCollectors.push(this.labelCollector)) : this.isRadial = !1, $ && D && ($.axis = this), this.isCircular = D
        }

        function J() {
          this.isRadial && this.beforeSetTickPositions()
        }

        function U(v) {
          let D = this.label;
          if (!D) return;
          let E = this.axis,
              W = D.getBBox(),
              q = E.options.labels,
              G = (E.translate(this.pos) + E.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,
              K = Math.round(G),
              Q = I(q.y) ? 0 : -(.3 * W.height),
              $ = q.y,
              it, at = 20,
              ht = q.align,
              rt = "end",
              et = K < 0 ? K + 360 : K,
              nt = et,
              lt = 0,
              dt = 0;
          E.isRadial && (it = E.getPosition(this.pos, E.center[2] / 2 + a(e(q.distance, -25), E.center[2] / 2, -E.center[2] / 2)), q.rotation === "auto" ? D.attr({
            rotation: G
          }) : I($) || ($ = E.chart.renderer.fontMetrics(D).b - W.height / 2), I(ht) || (E.isCircular ? (W.width > E.len * E.tickInterval / (E.max - E.min) && (at = 0), ht = G > at && G < 180 - at ? "left" : G > 180 + at && G < 360 - at ? "right" : "center") : ht = "center", D.attr({
            align: ht
          })), ht === "auto" && E.tickPositions.length === 2 && E.isCircular && (et > 90 && et < 180 ? et = 180 - et : et > 270 && et <= 360 && (et = 540 - et), nt > 180 && nt <= 360 && (nt = 360 - nt), (E.pane.options.startAngle === K || E.pane.options.startAngle === K + 360 || E.pane.options.startAngle === K - 360) && (rt = "start"), ht = K >= -90 && K <= 90 || K >= -360 && K <= -270 || K >= 270 && K <= 360 ? rt === "start" ? "right" : "left" : rt === "start" ? "left" : "right", nt > 70 && nt < 110 && (ht = "center"), et < 15 || et >= 180 && et < 195 ? lt = .3 * W.height : et >= 15 && et <= 35 ? lt = rt === "start" ? 0 : .75 * W.height : et >= 195 && et <= 215 ? lt = rt === "start" ? .75 * W.height : 0 : et > 35 && et <= 90 ? lt = rt === "start" ? -(.25 * W.height) : W.height : et > 215 && et <= 270 && (lt = rt === "start" ? W.height : -(.25 * W.height)), nt < 15 ? dt = rt === "start" ? -(.15 * W.height) : .15 * W.height : nt > 165 && nt <= 180 && (dt = rt === "start" ? .15 * W.height : -(.15 * W.height)), D.attr({
            align: ht
          }), D.translate(dt, lt + Q)), v.pos.x = it.x + (q.x || 0), v.pos.y = it.y + ($ || 0))
        }

        function l(v) {
          this.axis.getPosition && M(v.pos, this.axis.getPosition(this.pos))
        }

        function N(v, D) {
          let E = this.chart,
              W = this.center;
          return v = this.startAngleRad + v, {
            x: E.plotLeft + W[0] + Math.cos(v) * D,
            y: E.plotTop + W[1] + Math.sin(v) * D
          }
        }

        function V() {
          this.isDirty = !1
        }

        function O() {
          let v, D;
          this.constructor.prototype.setAxisSize.call(this), this.isRadial && (this.pane.updateCenter(this), v = this.center = this.pane.center.slice(), this.isCircular ? this.sector = this.endAngleRad - this.startAngleRad : (D = this.postTranslate(this.angleRad, v[3] / 2), v[0] = D.x - this.chart.plotLeft, v[1] = D.y - this.chart.plotTop), this.len = this.width = this.height = (v[2] - v[3]) * e(this.sector, 1) / 2)
        }

        function z() {
          this.constructor.prototype.setAxisTranslation.call(this), this.center && (this.isCircular ? this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : this.transA = (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.isXAxis ? this.minPixelPadding = this.transA * this.minPointOffset : this.minPixelPadding = 0)
        }

        function Z(v) {
          let {
            coll: D
          } = this, {
            angular: E,
            inverted: W,
            polar: q
          } = this.chart, G = {};
          E ? this.isXAxis || (G = b(j.yAxis, P)) : q && (G = this.horiz ? b(j.xAxis, r) : b(D === "xAxis" ? j.xAxis : j.yAxis, L)), W && D === "yAxis" && (G.stackLabels = n(j.yAxis, !0) ? j.yAxis.stackLabels : {}, G.reversedStacks = !0);
          let K = this.options = b(G, v);
          K.plotBands || (K.plotBands = []), y(this, "afterSetOptions")
        }

        function st(v, D, E, W, q, G, K) {
          let Q, $ = this.axis;
          return $.isRadial ? ["M", D, E, "L", (Q = $.getPosition(this.pos, $.center[2] / 2 + W)).x, Q.y] : v.call(this, D, E, W, q, G, K)
        }
        t.compose = function(v, D) {
          return p(T, "Axis.Radial") && (R(v, "afterInit", A), R(v, "autoLabelAlign", _), R(v, "destroy", F), R(v, "init", tt), R(v, "initialAxisTranslation", J), R(D, "afterGetLabelPosition", U), R(D, "afterGetPosition", l), s(D.prototype, "getMarkPath", st)), v
        }
      }(g || (g = {})), g
    }), ot(d, "Series/PolarComposition.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Globals.js"], d["Core/Series/Series.js"], d["Extensions/Pane/Pane.js"], d["Core/Axis/RadialAxis.js"], d["Core/Utilities.js"]], function(h, u, x, g, j, T) {
      let {
        animObject: k
      } = h, {
        composed: R
      } = u, {
        addEvent: H,
        defined: I,
        find: M,
        isNumber: y,
        merge: n,
        pick: b,
        pushUnique: e,
        relativeLength: p,
        splat: a,
        uniqueKey: s,
        wrap: t
      } = T;

      function r() {
        (this.pane || []).forEach(U => {
          U.render()
        })
      }

      function P(U) {
        let l = U.args[0].xAxis,
            N = U.args[0].yAxis,
            V = U.args[0].chart;
        l && N && (N.gridLineInterpolation === "polygon" ? (l.startOnTick = !0, l.endOnTick = !0) : l.gridLineInterpolation === "polygon" && V.inverted && (N.startOnTick = !0, N.endOnTick = !0))
      }

      function L() {
        this.pane || (this.pane = []), this.options.pane = a(this.options.pane), this.options.pane.forEach(U => {
          new g(U, this)
        }, this)
      }

      function B(U) {
        let l = U.args.marker,
            N = this.chart.xAxis[0],
            V = this.chart.yAxis[0],
            O = this.chart.inverted,
            z = O ? V : N,
            Z = O ? N : V;
        if (this.chart.polar) {
          U.preventDefault();
          let st = (l.attr ? l.attr("start") : l.start) - z.startAngleRad,
              v = l.attr ? l.attr("r") : l.r,
              D = (l.attr ? l.attr("end") : l.end) - z.startAngleRad,
              E = l.attr ? l.attr("innerR") : l.innerR;
          U.result.x = st + z.pos, U.result.width = D - st, U.result.y = Z.len + Z.pos - v, U.result.height = v - E
        }
      }

      function S(U) {
        let l = this.chart;
        if (l.polar && l.hoverPane && l.hoverPane.axis) {
          U.preventDefault();
          let N = l.hoverPane.center,
              V = l.mouseDownX || 0,
              O = l.mouseDownY || 0,
              z = U.args.chartY,
              Z = U.args.chartX,
              st = 2 * Math.PI,
              v = l.hoverPane.axis.startAngleRad,
              D = l.hoverPane.axis.endAngleRad,
              E = l.inverted ? l.xAxis[0] : l.yAxis[0],
              W = {},
              q = "arc";
          if (W.x = N[0] + l.plotLeft, W.y = N[1] + l.plotTop, this.zoomHor) {
            let G = v > 0 ? D - v : Math.abs(v) + Math.abs(D),
                K = Math.atan2(O - l.plotTop - N[1], V - l.plotLeft - N[0]) - v,
                Q = Math.atan2(z - l.plotTop - N[1], Z - l.plotLeft - N[0]) - v;
            W.r = N[2] / 2, W.innerR = N[3] / 2, K <= 0 && (K += st), Q <= 0 && (Q += st), Q < K && (Q = [K, K = Q][0]), G < st && v + Q > D + (st - G) / 2 && (Q = K, K = v <= 0 ? v : 0);
            let $ = W.start = Math.max(K + v, v),
                it = W.end = Math.min(Q + v, D);
            if (E.options.gridLineInterpolation === "polygon") {
              let at = l.hoverPane.axis,
                  ht = $ - at.startAngleRad + at.pos,
                  rt = E.getPlotLinePath({
                    value: E.max
                  }),
                  et = at.toValue(ht),
                  nt = at.toValue(ht + (it - $));
              if (et < at.getExtremes().min) {
                let {
                  min: lt,
                  max: dt
                } = at.getExtremes();
                et = dt - (lt - et)
              }
              if (nt < at.getExtremes().min) {
                let {
                  min: lt,
                  max: dt
                } = at.getExtremes();
                nt = dt - (lt - nt)
              }
              nt < et && (nt = [et, et = nt][0]), (rt = i(rt, et, nt, at)).push(["L", N[0] + l.plotLeft, l.plotTop + N[1]]), W.d = rt, q = "path"
            }
          }
          if (this.zoomVert) {
            let G = l.inverted ? l.xAxis[0] : l.yAxis[0],
                K = Math.sqrt(Math.pow(V - l.plotLeft - N[0], 2) + Math.pow(O - l.plotTop - N[1], 2)),
                Q = Math.sqrt(Math.pow(Z - l.plotLeft - N[0], 2) + Math.pow(z - l.plotTop - N[1], 2));
            if (Q < K && (K = [Q, Q = K][0]), Q > N[2] / 2 && (Q = N[2] / 2), K < N[3] / 2 && (K = N[3] / 2), this.zoomHor || (W.start = v, W.end = D), W.r = Q, W.innerR = K, G.options.gridLineInterpolation === "polygon") {
              let $ = G.toValue(G.len + G.pos - K),
                  it = G.toValue(G.len + G.pos - Q),
                  at = G.getPlotLinePath({
                    value: it
                  }).concat(G.getPlotLinePath({
                    value: $,
                    reverse: !0
                  }));
              W.d = at, q = "path"
            }
          }
          if (this.zoomHor && this.zoomVert && E.options.gridLineInterpolation === "polygon") {
            let G = l.hoverPane.axis,
                K = W.start || 0,
                Q = W.end || 0,
                $ = K - G.startAngleRad + G.pos,
                it = G.toValue($),
                at = G.toValue($ + (Q - K));
            if (W.d instanceof Array) {
              let ht = W.d.slice(0, W.d.length / 2),
                  rt = W.d.slice(W.d.length / 2, W.d.length);
              rt = [...rt].reverse();
              let et = l.hoverPane.axis;
              ht = i(ht, it, at, et), (rt = i(rt, it, at, et)) && (rt[0][0] = "L"), rt = [...rt].reverse(), W.d = ht.concat(rt), q = "path"
            }
          }
          U.attrs = W, U.shapeType = q
        }
      }

      function Y() {
        let U = this.chart;
        U.polar && (this.polar = new J(this), U.inverted && (this.isRadialSeries = !0, this.is("column") && (this.isRadialBar = !0)))
      }

      function X() {
        if (this.chart.polar && this.xAxis) {
          let {
            xAxis: U,
            yAxis: l
          } = this, N = this.chart;
          this.kdByAngle = N.tooltip && N.tooltip.shared, this.kdByAngle || N.inverted ? this.searchPoint = C : this.options.findNearestPointBy = "xy";
          let V = this.points,
              O = V.length;
          for (; O--;) this.is("column") || this.is("columnrange") || this.polar.toXY(V[O]), N.hasParallelCoordinates || this.yAxis.reversed || (b(V[O].y, Number.MIN_VALUE) < l.min || V[O].x < U.min || V[O].x > U.max ? (V[O].isNull = !0, V[O].plotY = NaN) : V[O].isNull = V[O].isValid && !V[O].isValid());
          this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(H(this, "afterRender", function() {
            let z;
            N.polar && this.options.clip !== !1 && (z = this.yAxis.pane.center, this.clipCircle ? this.clipCircle.animate({
              x: z[0],
              y: z[1],
              r: z[2] / 2,
              innerR: z[3] / 2
            }) : this.clipCircle = function(Z, st, v, D, E) {
              let W = s(),
                  q = Z.createElement("clipPath").attr({
                    id: W
                  }).add(Z.defs),
                  G = E ? Z.arc(st, v, D, E, 0, 2 * Math.PI).add(q) : Z.circle(st, v, D).add(q);
              return G.id = W, G.clipPath = q, G
            }(N.renderer, z[0], z[1], z[2] / 2, z[3] / 2), this.group.clip(this.clipCircle), this.setClip = u.noop)
          })))
        }
      }

      function C(U) {
        let l = this.chart,
            N = this.xAxis,
            V = this.yAxis,
            O = N.pane && N.pane.center,
            z = U.chartX - (O && O[0] || 0) - l.plotLeft,
            Z = U.chartY - (O && O[1] || 0) - l.plotTop,
            st = l.inverted ? {
              clientX: U.chartX - V.pos,
              plotY: U.chartY - N.pos
            } : {
              clientX: 180 + -180 / Math.PI * Math.atan2(z, Z)
            };
        return this.searchKDTree(st)
      }

      function i(U, l, N, V) {
        let O = V.tickInterval,
            z = V.tickPositions,
            Z = M(z, v => v >= N),
            st = M([...z].reverse(), v => v <= l);
        return I(Z) || (Z = z[z.length - 1]), I(st) || (st = z[0], Z += O, U[0][0] = "L", U.unshift(U[U.length - 3])), (U = U.slice(z.indexOf(st), z.indexOf(Z) + 1))[0][0] = "M", U
      }

      function o(U, l) {
        return M(this.pane || [], N => N.options.id === l) || U.call(this, l)
      }

      function f(U, l, N, V, O, z) {
        let Z, st, v, D = this.chart,
            E = b(V.inside, !!this.options.stacking);
        if (D.polar) {
          if (Z = l.rectPlotX / Math.PI * 180, D.inverted) this.forceDL = D.isInsidePlot(l.plotX, l.plotY), E && l.shapeArgs ? (st = l.shapeArgs, O = n(O, {
            x: (v = this.yAxis.postTranslate(((st.start || 0) + (st.end || 0)) / 2 - this.xAxis.startAngleRad, l.barX + l.pointWidth / 2)).x - D.plotLeft,
            y: v.y - D.plotTop
          })) : l.tooltipPos && (O = n(O, {
            x: l.tooltipPos[0],
            y: l.tooltipPos[1]
          })), V.align = b(V.align, "center"), V.verticalAlign = b(V.verticalAlign, "middle");
          else {
            var W;
            let q, G;
            (W = V).align === null && (q = Z > 20 && Z < 160 ? "left" : Z > 200 && Z < 340 ? "right" : "center", W.align = q), W.verticalAlign === null && (G = Z < 45 || Z > 315 ? "bottom" : Z > 135 && Z < 225 ? "top" : "middle", W.verticalAlign = G), V = W
          }
          x.prototype.alignDataLabel.call(this, l, N, V, O, z), this.isRadialBar && l.shapeArgs && l.shapeArgs.start === l.shapeArgs.end ? N.hide() : N.show()
        } else U.call(this, l, N, V, O, z)
      }

      function m() {
        let U = this.options,
            l = U.stacking,
            N = this.chart,
            V = this.xAxis,
            O = this.yAxis,
            z = O.reversed,
            Z = O.center,
            st = V.startAngleRad,
            v = V.endAngleRad - st,
            D = U.threshold,
            E = 0,
            W, q, G, K, Q, $ = 0,
            it = 0,
            at, ht, rt, et, nt, lt, dt, xt;
        if (V.isRadial)
          for (G = (W = this.points).length, K = O.translate(O.min), Q = O.translate(O.max), D = U.threshold || 0, N.inverted && y(D) && I(E = O.translate(D)) && (E < 0 ? E = 0 : E > v && (E = v), this.translatedThreshold = E + st); G--;) {
            if (lt = (q = W[G]).barX, ht = q.x, rt = q.y, q.shapeType = "arc", N.inverted) {
              q.plotY = O.translate(rt), l && O.stacking ? (nt = O.stacking.stacks[(rt < 0 ? "-" : "") + this.stackKey], this.visible && nt && nt[ht] && !q.isNull && (et = nt[ht].points[this.getStackIndicator(void 0, ht, this.index).key], $ = O.translate(et[0]), it = O.translate(et[1]), I($) && ($ = T.clamp($, 0, v)))) : ($ = E, it = q.plotY), $ > it && (it = [$, $ = it][0]), z ? it > K ? it = K : $ < Q ? $ = Q : ($ > K || it < Q) && ($ = it = v) : $ < K ? $ = K : it > Q ? it = Q : (it < K || $ > Q) && ($ = it = 0), O.min > O.max && ($ = it = z ? v : 0), $ += st, it += st, Z && (q.barX = lt += Z[3] / 2), dt = Math.max(lt, 0), xt = Math.max(lt + q.pointWidth, 0);
              let ut = U.borderRadius,
                  bt = p((typeof ut == "object" ? ut.radius : ut) || 0, xt - dt);
              q.shapeArgs = {
                x: Z[0],
                y: Z[1],
                r: xt,
                innerR: dt,
                start: $,
                end: it,
                borderRadius: bt
              }, q.opacity = $ === it ? 0 : void 0, q.plotY = (I(this.translatedThreshold) && ($ < this.translatedThreshold ? $ : it)) - st
            } else $ = lt + st, q.shapeArgs = this.polar.arc(q.yBottom, q.plotY, $, $ + q.pointWidth), q.shapeArgs.borderRadius = 0;
            this.polar.toXY(q), N.inverted ? (at = O.postTranslate(q.rectPlotY, lt + q.pointWidth / 2), q.tooltipPos = [at.x - N.plotLeft, at.y - N.plotTop]) : q.tooltipPos = [q.plotX, q.plotY], Z && (q.ttBelow = q.plotY > Z[1])
          }
      }

      function w(U, l) {
        let N, V, O = this;
        if (this.chart.polar) {
          l = l || this.points;
          for (let Z = 0; Z < l.length; Z++)
            if (!l[Z].isNull) {
              N = Z;
              break
            } this.options.connectEnds !== !1 && N !== void 0 && (this.connectEnds = !0, l.splice(l.length, 0, l[N]), V = !0), l.forEach(Z => {
            Z.polarPlotY === void 0 && O.polar.toXY(Z)
          })
        }
        let z = U.apply(this, [].slice.call(arguments, 1));
        return V && l.pop(), z
      }

      function c(U, l) {
        let N = this.chart,
            V = {
              xAxis: [],
              yAxis: []
            };
        return N.polar ? N.axes.forEach(O => {
          if (O.coll === "colorAxis") return;
          let z = O.isXAxis,
              Z = O.center,
              st = l.chartX - Z[0] - N.plotLeft,
              v = l.chartY - Z[1] - N.plotTop;
          V[z ? "xAxis" : "yAxis"].push({
            axis: O,
            value: O.translate(z ? Math.PI - Math.atan2(st, v) : Math.sqrt(Math.pow(st, 2) + Math.pow(v, 2)), !0)
          })
        }) : V = U.call(this, l), V
      }

      function A(U, l) {
        this.chart.polar || U.call(this, l)
      }

      function _(U, l) {
        let N = this,
            V = this.chart,
            O = this.group,
            z = this.markerGroup,
            Z = this.xAxis && this.xAxis.center,
            st = V.plotLeft,
            v = V.plotTop,
            D = this.options.animation,
            E, W, q, G, K, Q;
        V.polar ? N.isRadialBar ? l || (N.startAngleRad = b(N.translatedThreshold, N.xAxis.startAngleRad), u.seriesTypes.pie.prototype.animate.call(N, l)) : (D = k(D), N.is("column") ? l || (W = Z[3] / 2, N.points.forEach($ => {
          q = $.graphic, K = (G = $.shapeArgs) && G.r, Q = G && G.innerR, q && G && (q.attr({
            r: W,
            innerR: W
          }), q.animate({
            r: K,
            innerR: Q
          }, N.options.animation))
        })) : l ? (E = {
          translateX: Z[0] + st,
          translateY: Z[1] + v,
          scaleX: .001,
          scaleY: .001
        }, O.attr(E), z && z.attr(E)) : (E = {
          translateX: st,
          translateY: v,
          scaleX: 1,
          scaleY: 1
        }, O.animate(E, D), z && z.animate(E, D))) : U.call(this, l)
      }

      function F(U, l, N, V) {
        let O, z;
        if (this.chart.polar)
          if (V) {
            let Z = (z = function v(D, E, W, q) {
                  let G, K, Q, $, it, at, ht = q ? 1 : 0,
                      rt = (G = E >= 0 && E <= D.length - 1 ? E : E < 0 ? D.length - 1 + E : 0) - 1 < 0 ? D.length - (1 + ht) : G - 1,
                      et = G + 1 > D.length - 1 ? ht : G + 1,
                      nt = D[rt],
                      lt = D[et],
                      dt = nt.plotX,
                      xt = nt.plotY,
                      ut = lt.plotX,
                      bt = lt.plotY,
                      ct = D[G].plotX,
                      mt = D[G].plotY;
                  K = (1.5 * ct + dt) / 2.5, Q = (1.5 * mt + xt) / 2.5, $ = (1.5 * ct + ut) / 2.5, it = (1.5 * mt + bt) / 2.5;
                  let ft = Math.sqrt(Math.pow(K - ct, 2) + Math.pow(Q - mt, 2)),
                      Pt = Math.sqrt(Math.pow($ - ct, 2) + Math.pow(it - mt, 2)),
                      St = Math.atan2(Q - mt, K - ct);
                  at = Math.PI / 2 + (St + Math.atan2(it - mt, $ - ct)) / 2, Math.abs(St - at) > Math.PI / 2 && (at -= Math.PI), K = ct + Math.cos(at) * ft, Q = mt + Math.sin(at) * ft;
                  let Mt = {
                    rightContX: $ = ct + Math.cos(Math.PI + at) * Pt,
                    rightContY: it = mt + Math.sin(Math.PI + at) * Pt,
                    leftContX: K,
                    leftContY: Q,
                    plotX: ct,
                    plotY: mt
                  };
                  return W && (Mt.prevPointCont = v(D, rt, !1, q)), Mt
                }(l, V, !0, this.connectEnds)).prevPointCont && z.prevPointCont.rightContX,
                st = z.prevPointCont && z.prevPointCont.rightContY;
            O = ["C", y(Z) ? Z : z.plotX, y(st) ? st : z.plotY, y(z.leftContX) ? z.leftContX : z.plotX, y(z.leftContY) ? z.leftContY : z.plotY, z.plotX, z.plotY]
          } else O = ["M", N.plotX, N.plotY];
        else O = U.call(this, l, N, V);
        return O
      }

      function tt(U, l, N = this.plotY) {
        if (!this.destroyed) {
          let {
            plotX: V,
            series: O
          } = this, {
            chart: z
          } = O;
          return z.polar && y(V) && y(N) ? [V + (l ? z.plotLeft : 0), N + (l ? z.plotTop : 0)] : U.call(this, l, N)
        }
      }
      class J {
        static compose(l, N, V, O, z, Z, st, v, D, E) {
          if (g.compose(N, V), j.compose(l, z), e(R, "Polar")) {
            let W = N.prototype,
                q = Z.prototype,
                G = V.prototype,
                K = O.prototype;
            if (H(N, "afterDrawChartBox", r), H(N, "getAxes", L), H(N, "init", P), t(W, "get", o), t(G, "getCoordinates", c), t(G, "pinch", A), H(V, "getSelectionMarkerAttrs", S), H(V, "getSelectionBox", B), H(O, "afterInit", Y), H(O, "afterTranslate", X, {
              order: 2
            }), H(O, "afterColumnTranslate", m, {
              order: 4
            }), t(K, "animate", _), t(q, "pos", tt), v) {
              let Q = v.prototype;
              t(Q, "alignDataLabel", f), t(Q, "animate", _)
            }
            if (D && t(D.prototype, "getGraphPath", w), E) {
              let Q = E.prototype;
              t(Q, "getPointSpline", F), st && (st.prototype.getPointSpline = Q.getPointSpline)
            }
          }
        }
        constructor(l) {
          this.series = l
        }
        arc(l, N, V, O) {
          let z = this.series,
              Z = z.xAxis.center,
              st = z.yAxis.len,
              v = Z[3] / 2,
              D = st - N + v,
              E = st - b(l, st) + v;
          return z.yAxis.reversed && (D < 0 && (D = v), E < 0 && (E = v)), {
            x: Z[0],
            y: Z[1],
            r: D,
            innerR: E,
            start: V,
            end: O
          }
        }
        toXY(l) {
          let N = this.series,
              V = N.chart,
              O = N.xAxis,
              z = N.yAxis,
              Z = l.plotX,
              st = V.inverted,
              v = l.y,
              D = l.plotY,
              E = st ? Z : z.len - D,
              W;
          if (st && N && !N.isRadialBar && (l.plotY = D = y(v) ? z.translate(v) : 0), l.rectPlotX = Z, l.rectPlotY = D, z.center && (E += z.center[3] / 2), y(D)) {
            let q = st ? z.postTranslate(D, E) : O.postTranslate(Z, E);
            l.plotX = l.polarPlotX = q.x - V.plotLeft, l.plotY = l.polarPlotY = q.y - V.plotTop
          }
          N.kdByAngle ? ((W = (Z / Math.PI * 180 + O.pane.options.startAngle) % 360) < 0 && (W += 360), l.clientX = W) : l.clientX = l.plotX
        }
      }
      return J
    }), ot(d, "Core/Axis/WaterfallAxis.js", [d["Core/Globals.js"], d["Core/Axis/Stacking/StackItem.js"], d["Core/Utilities.js"]], function(h, u, x) {
      var g;
      let {
        composed: j
      } = h, {
        addEvent: T,
        objectEach: k,
        pushUnique: R
      } = x;
      return function(H) {
        function I() {
          let e = this.waterfall.stacks;
          e && (e.changed = !1, delete e.alreadyChanged)
        }

        function M() {
          let e = this.options.stackLabels;
          e && e.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals()
        }

        function y() {
          this.waterfall || (this.waterfall = new b(this))
        }

        function n() {
          let e = this.axes;
          for (let p of this.series)
            if (p.options.stacking) {
              for (let a of e) a.isXAxis || (a.waterfall.stacks.changed = !0);
              break
            }
        }
        H.compose = function(e, p) {
          R(j, "Axis.Waterfall") && (T(e, "init", y), T(e, "afterBuildStacks", I), T(e, "afterRender", M), T(p, "beforeRedraw", n))
        };
        class b {
          constructor(p) {
            this.axis = p, this.stacks = {
              changed: !1
            }
          }
          renderStackTotals() {
            let p = this.axis,
                a = p.waterfall.stacks,
                s = p.stacking && p.stacking.stackTotalGroup,
                t = new u(p, p.options.stackLabels || {}, !1, 0, void 0);
            this.dummyStackItem = t, s && k(a, r => {
              k(r, (P, L) => {
                t.total = P.stackTotal, t.x = +L, P.label && (t.label = P.label), u.prototype.render.call(t, s), P.label = t.label, delete t.label
              })
            }), t.total = null
          }
        }
        H.Composition = b
      }(g || (g = {})), g
    }), ot(d, "Series/Waterfall/WaterfallPoint.js", [d["Series/Column/ColumnSeries.js"], d["Core/Series/Point.js"], d["Core/Utilities.js"]], function(h, u, x) {
      let {
        isNumber: g
      } = x;
      class j extends h.prototype.pointClass {
        getClassName() {
          let k = u.prototype.getClassName.call(this);
          return this.isSum ? k += " highcharts-sum" : this.isIntermediateSum && (k += " highcharts-intermediate-sum"), k
        }
        isValid() {
          return g(this.y) || this.isSum || !!this.isIntermediateSum
        }
      }
      return j
    }), ot(d, "Series/Waterfall/WaterfallSeriesDefaults.js", [], function() {
      return {
        dataLabels: {
          inside: !0
        },
        lineWidth: 1,
        lineColor: "#333333",
        dashStyle: "Dot",
        borderColor: "#333333",
        states: {
          hover: {
            lineWidthPlus: 0
          }
        }
      }
    }), ot(d, "Series/Waterfall/WaterfallSeries.js", [d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"], d["Core/Axis/WaterfallAxis.js"], d["Series/Waterfall/WaterfallPoint.js"], d["Series/Waterfall/WaterfallSeriesDefaults.js"]], function(h, u, x, g, j) {
      let {
        column: T,
        line: k
      } = h.seriesTypes, {
        addEvent: R,
        arrayMax: H,
        arrayMin: I,
        correctFloat: M,
        extend: y,
        isNumber: n,
        merge: b,
        objectEach: e,
        pick: p
      } = u;

      function a(t, r) {
        return Object.hasOwnProperty.call(t, r)
      }
      class s extends T {
        generatePoints() {
          T.prototype.generatePoints.apply(this);
          for (let r = 0, P = this.points.length; r < P; r++) {
            let L = this.points[r],
                B = this.processedYData[r];
            n(B) && (L.isIntermediateSum || L.isSum) && (L.y = M(B))
          }
        }
        processData(r) {
          let P, L, B, S, Y, X, C = this.options,
              i = this.yData,
              o = C.data,
              f = i.length,
              m = C.threshold || 0;
          B = L = S = Y = 0;
          for (let w = 0; w < f; w++) X = i[w], P = o && o[w] ? o[w] : {}, X === "sum" || P.isSum ? i[w] = M(B) : X === "intermediateSum" || P.isIntermediateSum ? (i[w] = M(L), L = 0) : (B += X, L += X), S = Math.min(B, S), Y = Math.max(B, Y);
          super.processData.call(this, r), C.stacking || (this.dataMin = S + m, this.dataMax = Y)
        }
        toYData(r) {
          return r.isSum ? "sum" : r.isIntermediateSum ? "intermediateSum" : r.y
        }
        updateParallelArrays(r, P) {
          super.updateParallelArrays.call(this, r, P), (this.yData[0] === "sum" || this.yData[0] === "intermediateSum") && (this.yData[0] = null)
        }
        pointAttribs(r, P) {
          let L = this.options.upColor;
          L && !r.options.color && n(r.y) && (r.color = r.y > 0 ? L : void 0);
          let B = T.prototype.pointAttribs.call(this, r, P);
          return delete B.dashstyle, B
        }
        getGraphPath() {
          return [
            ["M", 0, 0]
          ]
        }
        getCrispPath() {
          let r = this.data.filter(o => n(o.y)),
              P = this.yAxis,
              L = r.length,
              B = Math.round(this.graph.strokeWidth()) % 2 / 2,
              S = Math.round(this.borderWidth) % 2 / 2,
              Y = this.xAxis.reversed,
              X = this.yAxis.reversed,
              C = this.options.stacking,
              i = [];
          for (let o = 1; o < L; o++) {
            if (!(this.options.connectNulls || n(this.data[r[o].index - 1].y))) continue;
            let f = r[o].box,
                m = r[o - 1],
                w = m.y || 0,
                c = r[o - 1].box;
            if (!f || !c) continue;
            let A = P.waterfall.stacks[this.stackKey],
                _ = w > 0 ? -c.height : 0;
            if (A && c && f) {
              let F, tt = A[o - 1];
              if (C) {
                let J = tt.connectorThreshold;
                F = Math.round(P.translate(J, !1, !0, !1, !0) + (X ? _ : 0)) - B
              } else F = c.y + m.minPointLengthOffset + S - B;
              i.push(["M", (c.x || 0) + (Y ? 0 : c.width || 0), F], ["L", (f.x || 0) + (Y && f.width || 0), F])
            }
            if (c && i.length && (!C && w < 0 && !X || w > 0 && X)) {
              let F = i[i.length - 2];
              F && typeof F[2] == "number" && (F[2] += c.height || 0);
              let tt = i[i.length - 1];
              tt && typeof tt[2] == "number" && (tt[2] += c.height || 0)
            }
          }
          return i
        }
        drawGraph() {
          k.prototype.drawGraph.call(this), this.graph && this.graph.attr({
            d: this.getCrispPath()
          })
        }
        setStackedPoints(r) {
          var V;
          let P = this.options,
              L = (V = r.waterfall) == null ? void 0 : V.stacks,
              B = P.threshold || 0,
              S = this.stackKey,
              Y = this.xData,
              X = Y.length,
              C = B,
              i = C,
              o, f = 0,
              m = 0,
              w = 0,
              c, A, _, F, tt, J, U, l, N = (O, z, Z, st) => {
                if (o) {
                  if (c)
                    for (; Z < c; Z++) o.stackState[Z] += st;
                  else o.stackState[0] = O, c = o.stackState.length;
                  o.stackState.push(o.stackState[c - 1] + z)
                }
              };
          if (r.stacking && L && this.reserveSpace()) {
            l = L.changed, (U = L.alreadyChanged) && 0 > U.indexOf(S) && (l = !0), L[S] || (L[S] = {});
            let O = L[S];
            if (O)
              for (let z = 0; z < X; z++)(!O[J = Y[z]] || l) && (O[J] = {
                negTotal: 0,
                posTotal: 0,
                stackTotal: 0,
                threshold: 0,
                stateIndex: 0,
                stackState: [],
                label: l && O[J] ? O[J].label : void 0
              }), o = O[J], (tt = this.yData[z]) >= 0 ? o.posTotal += tt : o.negTotal += tt, F = P.data[z], A = o.absolutePos = o.posTotal, _ = o.absoluteNeg = o.negTotal, o.stackTotal = A + _, c = o.stackState.length, F && F.isIntermediateSum ? (N(w, m, 0, w), w = m, m = B, C ^= i, i ^= C, C ^= i) : F && F.isSum ? (N(B, f, c, 0), C = B) : (N(C, tt, 0, f), F && (f += tt, m += tt)), o.stateIndex++, o.threshold = C, C += o.stackTotal;
            L.changed = !1, L.alreadyChanged || (L.alreadyChanged = []), L.alreadyChanged.push(S)
          }
        }
        getExtremes() {
          let r, P, L, B = this.options.stacking;
          return B ? (r = this.yAxis.waterfall.stacks, P = this.stackedYNeg = [], L = this.stackedYPos = [], B === "overlap" ? e(r[this.stackKey], function(S) {
            P.push(I(S.stackState)), L.push(H(S.stackState))
          }) : e(r[this.stackKey], function(S) {
            P.push(S.negTotal + S.threshold), L.push(S.posTotal + S.threshold)
          }), {
            dataMin: I(P),
            dataMax: H(L)
          }) : {
            dataMin: this.dataMin,
            dataMax: this.dataMax
          }
        }
      }
      return s.defaultOptions = b(T.defaultOptions, j), s.compose = x.compose, y(s.prototype, {
        pointValKey: "y",
        showLine: !0,
        pointClass: g
      }), R(s, "afterColumnTranslate", function() {
        let {
          options: t,
          points: r,
          yAxis: P
        } = this, L = p(t.minPointLength, 5), B = L / 2, S = t.threshold || 0, Y = t.stacking, X = P.waterfall.stacks[this.stackKey], C = S, i = S, o, f, m, w;
        for (let c = 0; c < r.length; c++) {
          let A = r[c],
              _ = this.processedYData[c],
              F = y({
                x: 0,
                y: 0,
                width: 0,
                height: 0
              }, A.shapeArgs || {});
          A.box = F;
          let tt = [0, _],
              J = A.y || 0;
          if (Y) {
            if (X) {
              let l = X[c];
              Y === "overlap" ? (f = l.stackState[l.stateIndex--], o = J >= 0 ? f : f - J, a(l, "absolutePos") && delete l.absolutePos, a(l, "absoluteNeg") && delete l.absoluteNeg) : (J >= 0 ? (f = l.threshold + l.posTotal, l.posTotal -= J, o = f) : (f = l.threshold + l.negTotal, l.negTotal -= J, o = f - J), !l.posTotal && n(l.absolutePos) && a(l, "absolutePos") && (l.posTotal = l.absolutePos, delete l.absolutePos), !l.negTotal && n(l.absoluteNeg) && a(l, "absoluteNeg") && (l.negTotal = l.absoluteNeg, delete l.absoluteNeg)), A.isSum || (l.connectorThreshold = l.threshold + l.stackTotal), P.reversed ? (m = J >= 0 ? o - J : o + J, w = o) : (m = o, w = o - J), A.below = m <= S, F.y = P.translate(m, !1, !0, !1, !0), F.height = Math.abs(F.y - P.translate(w, !1, !0, !1, !0));
              let N = P.waterfall.dummyStackItem;
              N && (N.x = c, N.label = X[c].label, N.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[c], this.stackedYPos[c], void 0, this.xAxis))
            }
          } else o = Math.max(i, i + J) + tt[0], F.y = P.translate(o, !1, !0, !1, !0), A.isSum ? (F.y = P.translate(tt[1], !1, !0, !1, !0), F.height = Math.min(P.translate(tt[0], !1, !0, !1, !0), P.len) - F.y, A.below = tt[1] <= S) : A.isIntermediateSum ? (J >= 0 ? (m = tt[1] + C, w = C) : (m = C, w = tt[1] + C), P.reversed && (m ^= w, w ^= m, m ^= w), F.y = P.translate(m, !1, !0, !1, !0), F.height = Math.abs(F.y - Math.min(P.translate(w, !1, !0, !1, !0), P.len)), C += tt[1], A.below = m <= S) : (F.height = _ > 0 ? P.translate(i, !1, !0, !1, !0) - F.y : P.translate(i, !1, !0, !1, !0) - P.translate(i - _, !1, !0, !1, !0), i += _, A.below = i < S), F.height < 0 && (F.y += F.height, F.height *= -1);
          A.plotY = F.y = Math.round(F.y || 0) - this.borderWidth % 2 / 2, F.height = Math.max(Math.round(F.height || 0), .001), A.yBottom = F.y + F.height, F.height <= L && !A.isNull ? (F.height = L, F.y -= B, A.plotY = F.y, J < 0 ? A.minPointLengthOffset = -B : A.minPointLengthOffset = B) : (A.isNull && (F.width = 0), A.minPointLengthOffset = 0);
          let U = A.plotY + (A.negative ? F.height : 0);
          A.below && (A.plotY += F.height), A.tooltipPos && (this.chart.inverted ? A.tooltipPos[0] = P.len - U : A.tooltipPos[1] = U), A.isInside = this.isPointInside(A), b(!0, A.shapeArgs, F)
        }
      }, {
        order: 2
      }), h.registerSeriesType("waterfall", s), s
    }), ot(d, "masters/highcharts-more.src.js", [d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Extensions/Pane/Pane.js"], d["Series/Bubble/BubbleSeries.js"], d["Series/PackedBubble/PackedBubbleSeries.js"], d["Series/PolarComposition.js"], d["Series/Waterfall/WaterfallSeries.js"]], function(h, u, x, g, j, T, k) {
      return g.compose(h.Axis, h.Chart, h.Legend, h.Series), j.compose(h.Axis, h.Chart, h.Legend, h.Series), x.compose(h.Chart, h.Pointer), T.compose(h.Axis, h.Chart, h.Pointer, h.Series, h.Tick, h.Point, u.seriesTypes.areasplinerange, u.seriesTypes.column, u.seriesTypes.line, u.seriesTypes.spline), k.compose(h.Axis, h.Chart), h
    })
  })
})(Tt);
var Ft = Tt.exports;
const Ht = jt(Ft);
Ht(zt);
const wt = [...Wt.chartCategories],
    Ui = ({
            data: pt,
            status: gt,
            height: d,
            hideTicks: ot
          }) => {
      const {
        t: h
      } = Ot(), {
        width: u
      } = Gt(), x = Rt.useMemo(() => ({
        chart: {
          polar: !0,
          type: "line",
          backgroundColor: "transparent"
        },
        chartOptions: {
          pane: {
            height: d
          }
        },
        legend: {
          enabled: !1
        },
        xAxis: {
          categories: wt,
          tickmarkPlacement: "on",
          lineWidth: 0,
          labels: {
            enabled: !ot,
            formatter: g => Ct(yt.jsx(qt, {
              x: String(g.value),
              y: (pt == null ? void 0 : pt[g.value]) ?? "-",
              xText: h(`productIdeas.scores.${g.value}.shortTitle`)
            })),
            rotation: 0
          }
        },
        yAxis: {
          gridLineInterpolation: "polygon",
          lineWidth: 0,
          min: 0,
          labels: {
            enabled: !1
          },
          tickAmount: 4
        },
        plotOptions: {
          area: {
            fillColor: gt !== "loading" ? "rgba(18, 149, 237, 0.32)" : Lt.grey200,
            lineColor: gt !== "loading" ? "rgba(18, 149, 237, 1)" : Lt.grey200,
            borderWidth: 1
          }
        },
        pane: {
          size: d
        },
        series: [{
          type: "area",
          name: "",
          data: gt !== "loading" ? wt.map(g => (pt == null ? void 0 : pt[g]) ?? 0) : Ut,
          pointPlacement: "on",
          color: "rgba(18, 149, 237, 1)"
        }],
        tooltip: {
          formatter: function() {
            const g = this.x,
                j = pt == null ? void 0 : pt[g];
            return Ct(yt.jsx(Kt, {
              x: h(`productIdeas.scores.${g}.title`),
              y: j ?? "-"
            }))
          }
        }
      }), [pt, d, ot, gt, h]);
      return yt.jsx(Bt, {
        options: x,
        height: d + (ot ? 10 : 60)
      }, u)
    },
    Ut = [5, 9, 3, 8, 5, 10],
    qt = ({
            x: pt,
            y: gt,
            xText: d
          }) => {
      const ot = pt !== "marketResearchAndTrends" && pt !== "logisticsAndProfitability";
      return yt.jsx(At, {
        theme: Nt,
        children: yt.jsx("div", {
          children: yt.jsxs(Vt, {
            vertical: ot,
            children: [yt.jsx(Yt, {
              children: gt
            }), ot ? yt.jsx("br", {}) : yt.jsx(yt.Fragment, {
              children: " "
            }), yt.jsx(Xt, {
              children: d
            })]
          })
        })
      })
    },
    Vt = kt.div`
  display: flex;
  gap: ${pt=>pt.theme.spacing.sp4};
  align-items: center;
  text-align: center;
  ${pt=>pt.vertical&&It`
      flex-direction: column;
    `}
`,
    Xt = kt.div`
  ${Et};
`,
    Yt = kt.div`
  ${Dt};
  color: ${pt=>pt.theme.systemColors.black};
  text-align: center;
`,
    Kt = ({
            x: pt,
            y: gt
          }) => yt.jsx(At, {
      theme: Nt,
      children: yt.jsxs(Zt, {
        children: [yt.jsx(Xt, {
          children: pt
        }), yt.jsx(Yt, {
          children: gt
        })]
      })
    }),
    Zt = kt.div`
  display: flex;
  align-items: center;
  gap: ${pt=>pt.theme.spacing.sp8};
`;
export {
  Ui as ProductIdeasPolarChart
};
//# sourceMappingURL=PolarChart-OGRHqmAo.js.map
